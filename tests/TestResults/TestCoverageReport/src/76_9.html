<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/tests/ExpenseTrackerAPI.WebApi.Tests/E2E/UserWorkflows/UserRegistrationWorkflowTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Net;
using System.Net.Http.Json;
using ExpenseTrackerAPI.Contracts.Users;
using ExpenseTrackerAPI.WebApi.Tests.Common;
using ExpenseTrackerAPI.WebApi.Tests.Fixtures;
using FluentAssertions;

namespace ExpenseTrackerAPI.WebApi.Tests.E2E.UserWorkflows;

/// &lt;summary&gt;
/// E2E tests for user registration workflows.
/// Tests the complete registration flow including validation, success, and error scenarios.
/// &lt;/summary&gt;
public class UserRegistrationWorkflowTests : BaseE2ETest
{
    public UserRegistrationWorkflowTests(ExpenseTrackerApiFactory factory) : base(factory) { }

    [Fact]
    public async Task RegisterUser_WithValidData_ShouldCreateUserAndAllowLogin()
    {
        // Arrange
        var uniqueEmail = GenerateUniqueEmail(&quot;register&quot;);
        var name = &quot;Registration Test User&quot;;
        var password = TestConstants.TestUsers.NewUserPassword;

        // Act - Register
        var registerResponse = await RegisterUserAsync(name, uniqueEmail, password);

        // Assert - Registration successful
        registerResponse.StatusCode.Should().Be(HttpStatusCode.OK);
        var registerResult = await registerResponse.Content.ReadFromJsonAsync&lt;RegisterResponse&gt;();
        registerResult.Should().NotBeNull();
        registerResult!.Email.Should().Be(uniqueEmail);
        registerResult.Name.Should().Be(name);
        registerResult.Id.Should().BeGreaterThan(0);

        // Act - Login with new credentials
        var loginResponse = await LoginAsync(uniqueEmail, password);

        // Assert - Login successful
        loginResponse.StatusCode.Should().Be(HttpStatusCode.OK);
        var loginResult = await loginResponse.Content.ReadFromJsonAsync&lt;LoginResponse&gt;();
        loginResult.Should().NotBeNull();
        loginResult!.Token.Should().NotBeNullOrEmpty();
        loginResult.Email.Should().Be(uniqueEmail);
        loginResult.Id.Should().Be(registerResult.Id);
    }

    [Fact]
    public async Task RegisterUser_WithInitialBalance_ShouldSetCorrectBalance()
    {
        // Arrange
        var uniqueEmail = GenerateUniqueEmail(&quot;balance&quot;);
        var initialBalance = 1000.50m;

        // Act
        var registerResponse = await RegisterUserAsync(
            &quot;Balance Test User&quot;,
            uniqueEmail,
            TestConstants.TestUsers.NewUserPassword,
            initialBalance);

        // Assert
        registerResponse.StatusCode.Should().Be(HttpStatusCode.OK);
        var result = await registerResponse.Content.ReadFromJsonAsync&lt;RegisterResponse&gt;();
        result.Should().NotBeNull();
        result!.InitialBalance.Should().Be(initialBalance);
    }

    [Fact]
    public async Task RegisterUser_WithDuplicateEmail_ShouldReturnConflict()
    {
        // Arrange - First registration
        var uniqueEmail = GenerateUniqueEmail(&quot;duplicate&quot;);
        await RegisterUserAsync(&quot;First User&quot;, uniqueEmail, TestConstants.TestUsers.NewUserPassword);

        // Act - Second registration with same email
        var duplicateResponse = await RegisterUserAsync(
            &quot;Second User&quot;,
            uniqueEmail,
            TestConstants.TestUsers.NewUserPassword);

        // Assert
        duplicateResponse.StatusCode.Should().Be(HttpStatusCode.Conflict);
    }

    [Theory]
    [InlineData(&quot;&quot;, &quot;test@email.com&quot;, &quot;Password123!&quot;, &quot;Name is required&quot;)]
    [InlineData(&quot;Test User&quot;, &quot;&quot;, &quot;Password123!&quot;, &quot;Email&quot;)]
    [InlineData(&quot;Test User&quot;, &quot;invalid-email&quot;, &quot;Password123!&quot;, &quot;Email format is invalid&quot;)]
    [InlineData(&quot;Test User&quot;, &quot;test@email.com&quot;, &quot;&quot;, &quot;Password is required&quot;)]
    [InlineData(&quot;Test User&quot;, &quot;test@email.com&quot;, &quot;short&quot;, &quot;Password must be between 8 and 100 characters&quot;)]
    [InlineData(&quot;Test User&quot;, &quot;test@email.com&quot;, &quot;nouppercaseornumber!&quot;, &quot;Password must contain&quot;)]
    public async Task RegisterUser_WithInvalidData_ShouldReturnBadRequest(
        string name,
        string email,
        string password,
        string expectedErrorContains)
    {
        // Arrange
        // Use a unique valid email only when testing empty email (to avoid duplicate conflicts)
        // For invalid format tests, use the actual invalid email
        var testEmail = string.IsNullOrEmpty(email) ? &quot;&quot; : email;

        // If the email is empty string (testing required), use empty
        // If it&#39;s a valid email pattern, make it unique to avoid conflicts
        if (!string.IsNullOrEmpty(email) &amp;&amp; email.Contains(&quot;@&quot;) &amp;&amp; email.Contains(&quot;.&quot;))
        {
            testEmail = $&quot;{Guid.NewGuid():N}.{email}&quot;;
        }

        // Act
        var response = await RegisterUserAsync(name, testEmail, password);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        var content = await response.Content.ReadAsStringAsync();
        content.Should().Contain(expectedErrorContains);
    }

    [Fact]
    public async Task RegisterUser_ThenAccessProtectedEndpoint_WithToken_ShouldSucceed()
    {
        // Arrange - Register and login
        var uniqueEmail = GenerateUniqueEmail(&quot;protected&quot;);
        var result = await RegisterAndLoginAsync(
            &quot;Protected Test User&quot;,
            uniqueEmail,
            TestConstants.TestUsers.NewUserPassword);

        result.Should().NotBeNull();
        var (authenticatedClient, user) = result!.Value;

        // Act - Access protected endpoint
        var response = await authenticatedClient.GetAsync(TestConstants.Routes.UserProfile);

        // Note: GET on profile might not be implemented, but we&#39;re testing auth works
        // If not implemented, it should return NotFound or MethodNotAllowed, not Unauthorized
        response.StatusCode.Should().NotBe(HttpStatusCode.Unauthorized);
    }

    [Fact]
    public async Task LoginUser_WithInvalidPassword_ShouldReturnUnauthorized()
    {
        // Arrange - Use seeded user
        var email = TestConstants.TestUsers.SeededUser1Email;
        var wrongPassword = &quot;WrongP@ssw0rd!&quot;;

        // Act
        var response = await LoginAsync(email, wrongPassword);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
    }

    [Fact]
    public async Task LoginUser_WithNonExistentEmail_ShouldReturnUnauthorized()
    {
        // Arrange
        var nonExistentEmail = &quot;nonexistent@email.com&quot;;

        // Act
        var response = await LoginAsync(nonExistentEmail, TestConstants.TestUsers.NewUserPassword);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
    }

    [Fact]
    public async Task LoginUser_WithSeededUser_ShouldReturnValidToken()
    {
        // Arrange - Use seeded user credentials
        var email = TestConstants.TestUsers.SeededUser1Email;
        var password = TestConstants.TestUsers.SeededUserPassword;

        // Act
        var response = await LoginAsync(email, password);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var result = await response.Content.ReadFromJsonAsync&lt;LoginResponse&gt;();
        result.Should().NotBeNull();
        result!.Token.Should().NotBeNullOrEmpty();
        result.Email.Should().Be(email);
        result.Name.Should().Be(TestConstants.TestUsers.SeededUser1Name);
        result.ExpiresAt.Should().BeAfter(DateTime.UtcNow);
    }

    [Fact]
    public async Task AuthHealthCheck_ShouldReturnHealthy()
    {
        // Act
        var response = await Client.GetAsync(TestConstants.Routes.AuthHealth);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var content = await response.Content.ReadAsStringAsync();
        content.Should().Contain(&quot;Healthy&quot;);
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[16,78,16,91,1],[16,92,16,93,1],[16,94,16,95,1],[20,5,20,6,1],[22,9,22,59,1],[23,9,23,45,1],[24,9,24,64,1],[27,9,27,85,1],[30,9,30,68,1],[31,9,31,99,1],[32,9,32,45,1],[33,9,33,56,1],[34,9,34,47,1],[35,9,35,53,1],[38,9,38,69,1],[41,9,41,65,1],[42,9,42,90,1],[43,9,43,42,1],[44,9,44,56,1],[45,9,45,52,1],[46,9,46,55,1],[47,5,47,6,1],[51,5,51,6,1],[53,9,53,58,1],[54,9,54,39,1],[57,9,61,29,1],[64,9,64,68,1],[65,9,65,91,1],[66,9,66,37,1],[67,9,67,60,1],[68,5,68,6,1],[72,5,72,6,1],[74,9,74,60,1],[75,9,75,101,1],[78,9,81,54,1],[84,9,84,75,1],[85,5,85,6,1],[99,5,99,6,1],[103,9,103,66,1],[107,9,107,88,1],[108,9,108,10,1],[109,13,109,55,1],[110,9,110,10,1],[113,9,113,75,1],[116,9,116,68,1],[117,9,117,66,1],[118,9,118,57,1],[119,5,119,6,1],[123,5,123,6,1],[125,9,125,60,1],[126,9,129,54,1],[131,9,131,37,1],[132,9,132,57,1],[135,9,135,93,1],[139,9,139,73,1],[140,5,140,6,1],[144,5,144,6,1],[146,9,146,62,1],[147,9,147,46,1],[150,9,150,63,1],[153,9,153,70,1],[154,5,154,6,1],[158,5,158,6,1],[160,9,160,56,1],[163,9,163,100,1],[166,9,166,70,1],[167,5,167,6,1],[171,5,171,6,1],[173,9,173,62,1],[174,9,174,67,1],[177,9,177,58,1],[180,9,180,60,1],[181,9,181,80,1],[182,9,182,37,1],[183,9,183,51,1],[184,9,184,41,1],[185,9,185,74,1],[186,9,186,60,1],[187,5,187,6,1],[191,5,191,6,1],[193,9,193,79,1],[196,9,196,60,1],[197,9,197,66,1],[198,9,198,45,1],[199,5,199,6,1]]);
    </script>
  </body>
</html>