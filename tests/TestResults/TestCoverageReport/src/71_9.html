<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/tests/ExpenseTrackerAPI.WebApi.Tests/E2E/Errors/UserErrorFormatTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Net;
using System.Net.Http.Json;
using ExpenseTrackerAPI.Contracts.Users;
using ExpenseTrackerAPI.WebApi.Tests.Common;
using ExpenseTrackerAPI.WebApi.Tests.Fixtures;
using FluentAssertions;

namespace ExpenseTrackerAPI.WebApi.Tests.E2E.Errors;

/// &lt;summary&gt;
/// Tests RFC 9110 compliant error response formats for User endpoints.
/// Validates that all error responses follow proper structure and error keys don&#39;t contain dots.
/// &lt;/summary&gt;
public class UserErrorFormatTests : BaseE2ETest
{
    public UserErrorFormatTests(ExpenseTrackerApiFactory factory) : base(factory) { }

    #region Update Profile Error Format Tests

    [Fact]
    public async Task UpdateProfile_WithEmptyName_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: null,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();
        problemDetails.Should().NotBeNull();

        // Validate RFC 9110 compliance
        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue(
            &quot;response should conform to RFC 9110 ProblemDetails format&quot;);

        // Validate no dots in error keys
        var invalidKeys = ErrorResponseValidator.GetInvalidKeys(problemDetails!.Errors);
        invalidKeys.Should().BeEmpty(
            $&quot;error keys should not contain dots, but found: {string.Join(&quot;, &quot;, invalidKeys)}&quot;);

        problemDetails.Status.Should().Be(400);
        problemDetails.Errors.Should().NotBeNull();
        problemDetails.Errors.Should().ContainKey(&quot;Name&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithInvalidEmail_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: &quot;invalid-email-format&quot;,
            NewPassword: null,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();
        problemDetails.Should().NotBeNull();

        // Validate RFC 9110 compliance
        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();

        // Validate no dots in error keys
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue(
            &quot;error keys should not contain dots&quot;);

        problemDetails.Errors.Should().ContainKey(&quot;Email&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithWrongCurrentPassword_ShouldReturnUnauthorizedProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: null,
            CurrentPassword: &quot;WrongPassword123!&quot;,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ProblemDetailsResponse&gt;();
        problemDetails.Should().NotBeNull();

        // Validate RFC 9110 compliance
        ErrorResponseValidator.IsValidProblemDetails(problemDetails).Should().BeTrue();

        problemDetails!.Status.Should().Be(401);
        problemDetails.Title.Should().NotBeNullOrEmpty();
    }

    [Fact]
    public async Task UpdateProfile_WithWeakNewPassword_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: &quot;weakpassword&quot;,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;NewPassword&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithShortNewPassword_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: &quot;Short1!&quot;,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;NewPassword&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithEmptyCurrentPassword_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: null,
            CurrentPassword: &quot;&quot;,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;CurrentPassword&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithExcessivelyLongName_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var tooLongName = new string(&#39;A&#39;, 101); // Exceeds 100 char limit
        var request = new UpdateUserRequest(
            Name: tooLongName,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: null,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;Name&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithMultipleValidationErrors_ShouldReturnAllErrorsWithoutDotsInKeys()
    {
        // Arrange - Multiple validation errors
        var request = new UpdateUserRequest(
            Name: &quot;&quot;,
            Email: &quot;invalid-email&quot;,
            NewPassword: &quot;weak&quot;,
            CurrentPassword: &quot;&quot;,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();
        problemDetails.Should().NotBeNull();

        // Validate RFC 9110 compliance
        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();

        // Validate no dots in ANY error keys
        var invalidKeys = ErrorResponseValidator.GetInvalidKeys(problemDetails!.Errors);
        invalidKeys.Should().BeEmpty(
            $&quot;no error keys should contain dots, but found: {string.Join(&quot;, &quot;, invalidKeys)}&quot;);

        // Should have multiple errors
        problemDetails.Errors.Should().NotBeNull();
        problemDetails.Errors!.Count.Should().BeGreaterThan(1, &quot;multiple validation errors should be present&quot;);
    }

    [Fact]
    public async Task UpdateProfile_WithDuplicateEmail_ShouldReturnConflictProblemDetailsWithoutDotsInKeys()
    {
        // Arrange - Try to change to another user&#39;s email
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser2Email,
            NewPassword: null,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Conflict);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ProblemDetailsResponse&gt;();
        problemDetails.Should().NotBeNull();

        // Validate RFC 9110 compliance
        ErrorResponseValidator.IsValidProblemDetails(problemDetails).Should().BeTrue();

        problemDetails!.Status.Should().Be(409);
        problemDetails.Title.Should().NotBeNullOrEmpty();
    }

    #endregion

    #region Delete Profile Error Format Tests

    [Fact]
    public async Task DeleteProfile_WithoutConfirmation_ShouldReturnBadRequestProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new DeleteUserRequest(
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            ConfirmDeletion: false);

        // Act
        var response = await Client.SendAsync(new HttpRequestMessage
        {
            Method = HttpMethod.Delete,
            RequestUri = new Uri(TestConstants.Routes.UserProfile, UriKind.Relative),
            Content = JsonContent.Create(request)
        });

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;Confirmation&quot;);
    }

    [Fact]
    public async Task DeleteProfile_WithWrongPassword_ShouldReturnUnauthorizedProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new DeleteUserRequest(
            CurrentPassword: &quot;WrongPassword123!&quot;,
            ConfirmDeletion: true);

        // Act
        var response = await Client.SendAsync(new HttpRequestMessage
        {
            Method = HttpMethod.Delete,
            RequestUri = new Uri(TestConstants.Routes.UserProfile, UriKind.Relative),
            Content = JsonContent.Create(request)
        });

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidProblemDetails(problemDetails).Should().BeTrue();

        problemDetails!.Status.Should().Be(401);
    }

    [Fact]
    public async Task DeleteProfile_WithEmptyPassword_ShouldReturnValidationProblemDetailsWithoutDotsInKeys()
    {
        // Arrange
        var request = new DeleteUserRequest(
            CurrentPassword: &quot;&quot;,
            ConfirmDeletion: true);

        // Act
        var response = await Client.SendAsync(new HttpRequestMessage
        {
            Method = HttpMethod.Delete,
            RequestUri = new Uri(TestConstants.Routes.UserProfile, UriKind.Relative),
            Content = JsonContent.Create(request)
        });

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
        ErrorResponseValidator.AllKeysAreValid(problemDetails!.Errors).Should().BeTrue();

        problemDetails.Errors.Should().ContainKey(&quot;CurrentPassword&quot;);
    }

    #endregion

    #region RFC 9110 Compliance Tests

    [Fact]
    public async Task AllUserErrors_ShouldHaveProperStatusCodes()
    {
        // Test that error responses have status codes matching HTTP semantics

        // 400 Bad Request - validation error
        var validationRequest = new UpdateUserRequest(&quot;&quot;, &quot;invalid&quot;, null, &quot;&quot;, 0m);
        var validationResponse = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, validationRequest);
        validationResponse.StatusCode.Should().Be(HttpStatusCode.BadRequest);

        // 401 Unauthorized - wrong password
        var authRequest = new UpdateUserRequest(
            &quot;Name&quot;,
            TestConstants.TestUsers.SeededUser1Email,
            null,
            &quot;WrongPassword!&quot;,
            0m);
        var authResponse = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, authRequest);
        authResponse.StatusCode.Should().Be(HttpStatusCode.Unauthorized);

        // 409 Conflict - duplicate email
        var conflictRequest = new UpdateUserRequest(
            &quot;Name&quot;,
            TestConstants.TestUsers.SeededUser2Email,
            null,
            TestConstants.TestUsers.SeededUserPassword,
            0m);
        var conflictResponse = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, conflictRequest);
        conflictResponse.StatusCode.Should().Be(HttpStatusCode.Conflict);
    }

    [Fact]
    public async Task AllUserValidationErrors_ShouldIncludeRequiredProblemDetailsFields()
    {
        // Arrange
        var request = new UpdateUserRequest(&quot;&quot;, &quot;invalid&quot;, null, &quot;&quot;, 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        // RFC 9110 required fields
        problemDetails!.Status.Should().NotBeNull(&quot;status is required by RFC 9110&quot;);
        problemDetails.Status.Should().Be((int)response.StatusCode, &quot;status should match response code&quot;);

        // At least one of title or detail should be present
        var hasDescription = !string.IsNullOrWhiteSpace(problemDetails.Title) ||
                            !string.IsNullOrWhiteSpace(problemDetails.Detail);
        hasDescription.Should().BeTrue(&quot;either title or detail is required for problem description&quot;);
    }

    [Fact]
    public async Task AllUserErrors_ShouldHaveTraceIdForDebugging()
    {
        // Arrange
        var request = new UpdateUserRequest(&quot;&quot;, &quot;invalid&quot;, null, &quot;&quot;, 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

        // TraceId helps with debugging and correlation
        problemDetails!.TraceId.Should().NotBeNullOrEmpty(&quot;traceId should be present for request tracking&quot;);
    }

    [Theory]
    [InlineData(&quot;&quot;, &quot;valid@email.com&quot;, null, &quot;Password123!&quot;)]
    [InlineData(&quot;Valid Name&quot;, &quot;invalid-email&quot;, null, &quot;Password123!&quot;)]
    [InlineData(&quot;Valid Name&quot;, &quot;valid@email.com&quot;, &quot;weak&quot;, &quot;Password123!&quot;)]
    [InlineData(&quot;Valid Name&quot;, &quot;valid@email.com&quot;, null, &quot;&quot;)]
    public async Task UpdateProfile_ValidationErrors_ShouldNeverContainDotsInErrorKeys(
        string name, string email, string? newPassword, string currentPassword)
    {
        // Arrange
        var request = new UpdateUserRequest(name, email, newPassword, currentPassword, 0m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert
        if (response.StatusCode == HttpStatusCode.BadRequest)
        {
            var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

            if (problemDetails?.Errors != null)
            {
                var invalidKeys = ErrorResponseValidator.GetInvalidKeys(problemDetails.Errors);
                invalidKeys.Should().BeEmpty(
                    $&quot;error keys must not contain dots. Found invalid keys: {string.Join(&quot;, &quot;, invalidKeys)}&quot;);
            }
        }
    }

    [Fact]
    public async Task UpdateProfile_WithNegativeInitialBalance_ShouldHandleAppropriately()
    {
        // Arrange
        var request = new UpdateUserRequest(
            Name: &quot;Valid Name&quot;,
            Email: TestConstants.TestUsers.SeededUser1Email,
            NewPassword: null,
            CurrentPassword: TestConstants.TestUsers.SeededUserPassword,
            InitialBalance: -100.00m);

        // Act
        var response = await Client.PutAsJsonAsync(TestConstants.Routes.UserProfile, request);

        // Assert - May be OK or BadRequest depending on business rules
        if (response.StatusCode == HttpStatusCode.BadRequest)
        {
            var problemDetails = await response.Content.ReadFromJsonAsync&lt;ValidationProblemDetailsResponse&gt;();

            if (problemDetails != null)
            {
                ErrorResponseValidator.IsValidValidationProblemDetails(problemDetails).Should().BeTrue();
                ErrorResponseValidator.AllKeysAreValid(problemDetails.Errors).Should().BeTrue();
            }
        }
    }

    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[16,69,16,82,1],[16,83,16,84,1],[16,85,16,86,1],[22,5,22,6,1],[24,9,29,33,1],[32,9,32,95,1],[35,9,35,68,1],[37,9,37,107,1],[38,9,38,45,1],[41,9,42,74,1],[45,9,45,89,1],[46,9,47,97,1],[49,9,49,48,1],[50,9,50,52,1],[51,9,51,59,1],[52,5,52,6,1],[56,5,56,6,1],[58,9,63,33,1],[66,9,66,95,1],[69,9,69,68,1],[71,9,71,107,1],[72,9,72,45,1],[75,9,75,98,1],[78,9,79,51,1],[81,9,81,60,1],[82,5,82,6,1],[86,5,86,6,1],[88,9,93,33,1],[96,9,96,95,1],[99,9,99,70,1],[101,9,101,97,1],[102,9,102,45,1],[105,9,105,88,1],[107,9,107,49,1],[108,9,108,58,1],[109,5,109,6,1],[113,5,113,6,1],[115,9,120,33,1],[123,9,123,95,1],[126,9,126,68,1],[128,9,128,107,1],[130,9,130,98,1],[131,9,131,90,1],[133,9,133,66,1],[134,5,134,6,1],[138,5,138,6,1],[140,9,145,33,1],[148,9,148,95,1],[151,9,151,68,1],[153,9,153,107,1],[155,9,155,98,1],[156,9,156,90,1],[158,9,158,66,1],[159,5,159,6,1],[163,5,163,6,1],[165,9,170,33,1],[173,9,173,95,1],[176,9,176,68,1],[178,9,178,107,1],[180,9,180,98,1],[181,9,181,90,1],[183,9,183,70,1],[184,5,184,6,1],[188,5,188,6,1],[190,9,190,48,1],[191,9,196,33,1],[199,9,199,95,1],[202,9,202,68,1],[204,9,204,107,1],[206,9,206,98,1],[207,9,207,90,1],[209,9,209,59,1],[210,5,210,6,1],[214,5,214,6,1],[216,9,221,33,1],[224,9,224,95,1],[227,9,227,68,1],[229,9,229,107,1],[230,9,230,45,1],[233,9,233,98,1],[236,9,236,89,1],[237,9,238,96,1],[241,9,241,52,1],[242,9,242,112,1],[243,5,243,6,1],[247,5,247,6,1],[249,9,254,33,1],[257,9,257,95,1],[260,9,260,66,1],[262,9,262,97,1],[263,9,263,45,1],[266,9,266,88,1],[268,9,268,49,1],[269,9,269,58,1],[270,5,270,6,1],[278,5,278,6,1],[280,9,282,37,1],[285,9,290,12,1],[293,9,293,68,1],[295,9,295,107,1],[297,9,297,98,1],[298,9,298,90,1],[300,9,300,67,1],[301,5,301,6,1],[305,5,305,6,1],[307,9,309,36,1],[312,9,317,12,1],[320,9,320,70,1],[322,9,322,97,1],[324,9,324,88,1],[326,9,326,49,1],[327,5,327,6,1],[331,5,331,6,1],[333,9,335,36,1],[338,9,343,12,1],[346,9,346,68,1],[348,9,348,107,1],[350,9,350,98,1],[351,9,351,90,1],[353,9,353,70,1],[354,5,354,6,1],[362,5,362,6,1],[366,9,366,84,1],[367,9,367,115,1],[368,9,368,78,1],[371,9,376,17,1],[377,9,377,103,1],[378,9,378,74,1],[381,9,386,17,1],[387,9,387,111,1],[388,9,388,74,1],[389,5,389,6,1],[393,5,393,6,1],[395,9,395,74,1],[398,9,398,95,1],[401,9,401,107,1],[404,9,404,85,1],[405,9,405,106,1],[408,9,409,79,1],[410,9,410,102,1],[411,5,411,6,1],[415,5,415,6,1],[417,9,417,74,1],[420,9,420,95,1],[423,9,423,107,1],[426,9,426,109,1],[427,5,427,6,1],[436,5,436,6,1],[438,9,438,92,1],[441,9,441,95,1],[444,9,444,62,1],[445,9,445,10,1],[446,13,446,111,1],[448,13,448,48,1],[449,13,449,14,1],[450,17,450,96,1],[451,17,452,112,1],[453,13,453,14,1],[454,9,454,10,1],[455,5,455,6,1],[459,5,459,6,1],[461,9,466,39,1],[469,9,469,95,1],[472,9,472,62,1],[473,9,473,10,0],[474,13,474,111,0],[476,13,476,40,0],[477,13,477,14,0],[478,17,478,106,0],[479,17,479,97,0],[480,13,480,14,0],[481,9,481,10,0],[482,5,482,6,1]]);
    </script>
  </body>
</html>