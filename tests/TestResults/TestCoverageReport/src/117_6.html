<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/tests/ExpenseTrackerAPI.Domain.Tests/Entities/TransactionTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using ExpenseTrackerAPI.Domain.Entities;
using FluentAssertions;
using Xunit;

namespace ExpenseTrackerAPI.Domain.Tests.Entities;

/// &lt;summary&gt;
/// Tests for Transaction entity constructor validation and business rules
/// &lt;/summary&gt;
public class TransactionTests
{
    #region Test Data Helpers

    private static readonly DateOnly ValidDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-1));
    private const int ValidUserId = 1;
    private const decimal ValidAmount = 100.50m;
    private const string ValidSubject = &quot;Test transaction&quot;;
    private const PaymentMethod ValidPaymentMethod = PaymentMethod.CREDIT_CARD;
    private const int ValidCategoryId = 1;
    private const int ValidTransactionGroupId = 1;

    #endregion

    #region Valid Construction Tests

    [Fact]
    public void Constructor_WithValidExpenseData_ShouldCreateTransaction()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod,
            &quot;Some notes&quot;,
            ValidCategoryId,
            ValidTransactionGroupId);

        // Assert
        transaction.Should().NotBeNull();
        transaction.UserId.Should().Be(ValidUserId);
        transaction.TransactionType.Should().Be(TransactionType.EXPENSE);
        transaction.Amount.Should().Be(ValidAmount);
        transaction.SignedAmount.Should().Be(-ValidAmount); // Negative for expense
        transaction.Date.Should().Be(ValidDate);
        transaction.Subject.Should().Be(ValidSubject);
        transaction.Notes.Should().Be(&quot;Some notes&quot;);
        transaction.PaymentMethod.Should().Be(ValidPaymentMethod);
        transaction.CategoryId.Should().Be(ValidCategoryId);
        transaction.TransactionGroupId.Should().Be(ValidTransactionGroupId);
        transaction.CumulativeDelta.Should().Be(0); // Set by service layer
        transaction.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(1));
        transaction.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(1));
    }

    [Fact]
    public void Constructor_WithValidIncomeData_ShouldCreateTransaction()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.INCOME,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod,
            null,
            ValidCategoryId,
            null);

        // Assert
        transaction.Should().NotBeNull();
        transaction.TransactionType.Should().Be(TransactionType.INCOME);
        transaction.SignedAmount.Should().Be(ValidAmount); // Positive for income
        transaction.CategoryId.Should().Be(ValidCategoryId);
        transaction.TransactionGroupId.Should().BeNull();
        transaction.Notes.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithoutOptionalParameters_ShouldCreateTransaction()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Should().NotBeNull();
        transaction.Notes.Should().BeNull();
        transaction.CategoryId.Should().BeNull();
        transaction.TransactionGroupId.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithWhitespaceNotes_ShouldTrimAndSetToNull()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod,
            &quot;   &quot;);

        // Assert
        transaction.Notes.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithWhitespaceSubject_ShouldTrim()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            &quot;  Valid Subject  &quot;,
            ValidPaymentMethod);

        // Assert
        transaction.Subject.Should().Be(&quot;Valid Subject&quot;);
    }

    #endregion

    #region User ID Validation Tests

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(-100)]
    public void Constructor_WithInvalidUserId_ShouldThrowArgumentException(int invalidUserId)
    {
        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                invalidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                ValidDate,
                ValidSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;User ID must be a positive integer&quot;);
        exception.ParamName.Should().Be(&quot;userId&quot;);
    }

    [Theory]
    [InlineData(1)]
    [InlineData(999)]
    [InlineData(int.MaxValue)]
    public void Constructor_WithValidUserId_ShouldSucceed(int validUserId)
    {
        // Act
        var transaction = new Transaction(
            validUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.UserId.Should().Be(validUserId);
    }

    #endregion

    #region Amount Validation Tests

    [Theory]
    [InlineData(0)]
    [InlineData(-0.01)]
    [InlineData(-100)]
    public void Constructor_WithInvalidAmount_ShouldThrowArgumentException(decimal invalidAmount)
    {
        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                invalidAmount,
                ValidDate,
                ValidSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;Transaction amount must be greater than zero&quot;);
        exception.ParamName.Should().Be(&quot;amount&quot;);
    }

    [Theory]
    [InlineData(0.01)]
    [InlineData(1)]
    [InlineData(999999.99)]
    public void Constructor_WithValidAmount_ShouldSucceed(decimal validAmount)
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            validAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Amount.Should().Be(validAmount);
    }

    [Fact]
    public void Constructor_WithLargeAmount_ShouldSucceed()
    {
        // Arrange
        var largeAmount = 1_000_000m;

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            largeAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Amount.Should().Be(largeAmount);
    }

    #endregion

    #region Date Validation Tests

    [Fact]
    public void Constructor_WithDateTooOld_ShouldThrowArgumentException()
    {
        // Arrange
        var tooOldDate = new DateOnly(1899, 12, 31);

        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                tooOldDate,
                ValidSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;Transaction date must be between&quot;);
        exception.ParamName.Should().Be(&quot;date&quot;);
    }

    [Fact]
    public void Constructor_WithFutureDate_ShouldThrowArgumentException()
    {
        // Arrange
        var futureDate = DateOnly.FromDateTime(DateTime.Now.AddYears(2));

        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                futureDate,
                ValidSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;Transaction date must be between&quot;);
        exception.ParamName.Should().Be(&quot;date&quot;);
    }

    [Fact]
    public void Constructor_WithDateAtMinBoundary_ShouldSucceed()
    {
        // Arrange
        var minDate = new DateOnly(1900, 1, 1);

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            minDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Date.Should().Be(minDate);
    }

    [Fact]
    public void Constructor_WithDateAtMaxBoundary_ShouldSucceed()
    {
        // Arrange
        var maxDate = DateOnly.FromDateTime(DateTime.Now.AddYears(1));

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            maxDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Date.Should().Be(maxDate);
    }

    [Fact]
    public void Constructor_WithToday_ShouldSucceed()
    {
        // Arrange
        var today = DateOnly.FromDateTime(DateTime.Today);

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            today,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Date.Should().Be(today);
    }

    #endregion

    #region Subject Validation Tests

    [Theory]
    [InlineData(null)]
    [InlineData(&quot;&quot;)]
    [InlineData(&quot;   &quot;)]
    [InlineData(&quot;\t&quot;)]
    [InlineData(&quot;\n&quot;)]
    public void Constructor_WithInvalidSubject_ShouldThrowArgumentException(string invalidSubject)
    {
        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                ValidDate,
                invalidSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;Transaction subject is required and cannot be empty&quot;);
        exception.ParamName.Should().Be(&quot;subject&quot;);
    }

    [Fact]
    public void Constructor_WithSubjectTooLong_ShouldThrowArgumentException()
    {
        // Arrange
        var longSubject = new string(&#39;A&#39;, 256); // 256 characters

        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                ValidDate,
                longSubject,
                ValidPaymentMethod));

        exception.Message.Should().Contain(&quot;Transaction subject cannot exceed 255 characters&quot;);
        exception.ParamName.Should().Be(&quot;subject&quot;);
    }

    [Fact]
    public void Constructor_WithSubjectAtMaxLength_ShouldSucceed()
    {
        // Arrange
        var maxLengthSubject = new string(&#39;A&#39;, 255); // 255 characters

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            maxLengthSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Subject.Should().Be(maxLengthSubject);
    }

    [Theory]
    [InlineData(&quot;Valid subject&quot;)]
    [InlineData(&quot;A&quot;)]
    [InlineData(&quot;Grocery shopping at Whole Foods&quot;)]
    public void Constructor_WithValidSubject_ShouldSucceed(string validSubject)
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            validSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Subject.Should().Be(validSubject);
    }

    #endregion

    #region Category Validation Tests

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(-100)]
    public void Constructor_WithInvalidCategoryId_ShouldThrowArgumentException(int invalidCategoryId)
    {
        // Act &amp; Assert
        var exception = Assert.Throws&lt;ArgumentException&gt;(() =&gt;
            new Transaction(
                ValidUserId,
                TransactionType.EXPENSE,
                ValidAmount,
                ValidDate,
                ValidSubject,
                ValidPaymentMethod,
                null,
                invalidCategoryId));

        exception.Message.Should().Contain(&quot;Category ID must be a positive integer when provided&quot;);
        exception.ParamName.Should().Be(&quot;categoryId&quot;);
    }

    [Theory]
    [InlineData(null)]
    [InlineData(1)]
    [InlineData(999)]
    public void Constructor_WithValidCategoryId_ShouldSucceed(int? validCategoryId)
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod,
            null,
            validCategoryId);

        // Assert
        transaction.CategoryId.Should().Be(validCategoryId);
    }

    #endregion

    #region Transaction Type Tests

    [Fact]
    public void Constructor_WithExpenseType_ShouldSetNegativeSignedAmount()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.TransactionType.Should().Be(TransactionType.EXPENSE);
        transaction.SignedAmount.Should().Be(-ValidAmount);
    }

    [Fact]
    public void Constructor_WithIncomeType_ShouldSetPositiveSignedAmount()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.INCOME,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Assert
        transaction.TransactionType.Should().Be(TransactionType.INCOME);
        transaction.SignedAmount.Should().Be(ValidAmount);
    }

    #endregion

    #region UpdateCumulativeDelta Tests

    [Fact]
    public void UpdateCumulativeDelta_ShouldUpdateValueAndTimestamp()
    {
        // Arrange
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        var originalUpdatedAt = transaction.UpdatedAt;
        var newCumulativeDelta = 1500.75m;

        // Wait a bit to ensure timestamp changes
        Thread.Sleep(10);

        // Act
        transaction.UpdateCumulativeDelta(newCumulativeDelta);

        // Assert
        transaction.CumulativeDelta.Should().Be(newCumulativeDelta);
        transaction.UpdatedAt.Should().BeAfter(originalUpdatedAt);
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1000.50)]
    [InlineData(1000.50)]
    [InlineData(999999.99)]
    public void UpdateCumulativeDelta_WithVariousValues_ShouldWork(decimal cumulativeDelta)
    {
        // Arrange
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        // Act
        transaction.UpdateCumulativeDelta(cumulativeDelta);

        // Assert
        transaction.CumulativeDelta.Should().Be(cumulativeDelta);
    }

    #endregion

    #region Edge Cases and Integration Tests

    [Fact]
    public void Constructor_WithAllOptionalParametersNull_ShouldSucceed()
    {
        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.INCOME,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod,
            null,
            null,
            null);

        // Assert
        transaction.Should().NotBeNull();
        transaction.Notes.Should().BeNull();
        transaction.CategoryId.Should().BeNull();
        transaction.TransactionGroupId.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithMinimalValidData_ShouldCreateValidTransaction()
    {
        // Arrange
        var minimalSubject = &quot;A&quot;;
        var minimalAmount = 0.01m;
        var minimalUserId = 1;

        // Act
        var transaction = new Transaction(
            minimalUserId,
            TransactionType.EXPENSE,
            minimalAmount,
            ValidDate,
            minimalSubject,
            ValidPaymentMethod);

        // Assert
        transaction.Should().NotBeNull();
        transaction.UserId.Should().Be(minimalUserId);
        transaction.Amount.Should().Be(minimalAmount);
        transaction.Subject.Should().Be(minimalSubject);
    }

    [Fact]
    public void Constructor_ShouldSetTimestampsToUtcNow()
    {
        // Arrange
        var beforeCreation = DateTime.UtcNow.AddSeconds(-1);

        // Act
        var transaction = new Transaction(
            ValidUserId,
            TransactionType.EXPENSE,
            ValidAmount,
            ValidDate,
            ValidSubject,
            ValidPaymentMethod);

        var afterCreation = DateTime.UtcNow.AddSeconds(1);

        // Assert
        transaction.CreatedAt.Should().BeAfter(beforeCreation);
        transaction.CreatedAt.Should().BeBefore(afterCreation);
        transaction.UpdatedAt.Should().BeAfter(beforeCreation);
        transaction.UpdatedAt.Should().BeBefore(afterCreation);
        transaction.CreatedAt.Should().BeCloseTo(transaction.UpdatedAt, TimeSpan.FromMilliseconds(100));
    }

    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[14,5,14,98,1],[16,5,16,49,1],[28,5,28,6,1],[30,9,39,38,1],[42,9,42,42,1],[43,9,43,53,1],[44,9,44,74,1],[45,9,45,53,1],[46,9,46,60,1],[47,9,47,49,1],[48,9,48,55,1],[49,9,49,53,1],[50,9,50,67,1],[51,9,51,61,1],[52,9,52,77,1],[53,9,53,52,1],[54,9,54,92,1],[55,9,55,92,1],[56,5,56,6,1],[60,5,60,6,1],[62,9,71,19,1],[74,9,74,42,1],[75,9,75,73,1],[76,9,76,59,1],[77,9,77,61,1],[78,9,78,58,1],[79,9,79,45,1],[80,5,80,6,1],[84,5,84,6,1],[86,9,92,33,1],[95,9,95,42,1],[96,9,96,45,1],[97,9,97,50,1],[98,9,98,58,1],[99,5,99,6,1],[103,5,103,6,1],[105,9,112,20,1],[115,9,115,45,1],[116,5,116,6,1],[120,5,120,6,1],[122,9,128,33,1],[131,9,131,58,1],[132,5,132,6,1],[143,5,143,6,1],[145,9,146,13,1],[146,13,152,36,1],[152,36,152,38,1],[154,9,154,82,1],[155,9,155,51,1],[156,5,156,6,1],[163,5,163,6,1],[165,9,171,33,1],[174,9,174,53,1],[175,5,175,6,1],[186,5,186,6,1],[188,9,189,13,1],[189,13,195,36,1],[195,36,195,38,1],[197,9,197,92,1],[198,9,198,51,1],[199,5,199,6,1],[206,5,206,6,1],[208,9,214,33,1],[217,9,217,53,1],[218,5,218,6,1],[222,5,222,6,1],[224,9,224,38,1],[227,9,233,33,1],[236,9,236,53,1],[237,5,237,6,1],[245,5,245,6,1],[247,9,247,53,1],[250,9,251,13,1],[251,13,257,36,1],[257,36,257,38,1],[259,9,259,80,1],[260,9,260,49,1],[261,5,261,6,1],[265,5,265,6,1],[267,9,267,74,1],[270,9,271,13,1],[271,13,277,36,1],[277,36,277,38,1],[279,9,279,80,1],[280,9,280,49,1],[281,5,281,6,1],[285,5,285,6,1],[287,9,287,48,1],[290,9,296,33,1],[299,9,299,47,1],[300,5,300,6,1],[304,5,304,6,1],[306,9,306,71,1],[309,9,315,33,1],[318,9,318,47,1],[319,5,319,6,1],[323,5,323,6,1],[325,9,325,59,1],[328,9,334,33,1],[337,9,337,45,1],[338,5,338,6,1],[351,5,351,6,1],[353,9,354,13,1],[354,13,360,36,1],[360,36,360,38,1],[362,9,362,99,1],[363,9,363,52,1],[364,5,364,6,1],[368,5,368,6,1],[370,9,370,48,1],[373,9,374,13,1],[374,13,380,36,1],[380,36,380,38,1],[382,9,382,96,1],[383,9,383,52,1],[384,5,384,6,1],[388,5,388,6,1],[390,9,390,53,1],[393,9,399,33,1],[402,9,402,59,1],[403,5,403,6,1],[410,5,410,6,1],[412,9,418,33,1],[421,9,421,55,1],[422,5,422,6,1],[433,5,433,6,1],[435,9,436,13,1],[436,13,444,35,1],[444,35,444,37,1],[446,9,446,100,1],[447,9,447,55,1],[448,5,448,6,1],[455,5,455,6,1],[457,9,465,30,1],[468,9,468,61,1],[469,5,469,6,1],[477,5,477,6,1],[479,9,485,33,1],[488,9,488,74,1],[489,9,489,60,1],[490,5,490,6,1],[494,5,494,6,1],[496,9,502,33,1],[505,9,505,73,1],[506,9,506,59,1],[507,5,507,6,1],[515,5,515,6,1],[517,9,523,33,1],[525,9,525,55,1],[526,9,526,43,1],[529,9,529,26,1],[532,9,532,63,1],[535,9,535,69,1],[536,9,536,67,1],[537,5,537,6,1],[545,5,545,6,1],[547,9,553,33,1],[556,9,556,60,1],[559,9,559,66,1],[560,5,560,6,1],[568,5,568,6,1],[570,9,579,19,1],[582,9,582,42,1],[583,9,583,45,1],[584,9,584,50,1],[585,9,585,58,1],[586,5,586,6,1],[590,5,590,6,1],[592,9,592,34,1],[593,9,593,35,1],[594,9,594,31,1],[597,9,603,33,1],[606,9,606,42,1],[607,9,607,55,1],[608,9,608,55,1],[609,9,609,57,1],[610,5,610,6,1],[614,5,614,6,1],[616,9,616,61,1],[619,9,625,33,1],[627,9,627,59,1],[630,9,630,64,1],[631,9,631,64,1],[632,9,632,64,1],[633,9,633,64,1],[634,9,634,105,1],[635,5,635,6,1]]);
    </script>
  </body>
</html>