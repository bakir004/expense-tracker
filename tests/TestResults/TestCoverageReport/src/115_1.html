<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/tests/ExpenseTrackerAPI.Application.Tests/TransactionGroups/TransactionGroupServiceTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using ErrorOr;
using ExpenseTrackerAPI.Application.TransactionGroups;
using ExpenseTrackerAPI.Application.TransactionGroups.Interfaces.Infrastructure;
using ExpenseTrackerAPI.Domain.Entities;
using ExpenseTrackerAPI.Domain.Errors;
using FluentAssertions;
using Moq;
using Xunit;

namespace ExpenseTrackerAPI.Application.Tests.TransactionGroups;

public class TransactionGroupServiceTests
{
    private readonly Mock&lt;ITransactionGroupRepository&gt; _mockTransactionGroupRepository;
    private readonly TransactionGroupService _transactionGroupService;

    public TransactionGroupServiceTests()
    {
        _mockTransactionGroupRepository = new Mock&lt;ITransactionGroupRepository&gt;();
        _transactionGroupService = new TransactionGroupService(_mockTransactionGroupRepository.Object);
    }

    #region Constructor Tests

    [Fact]
    public void Constructor_WithNullTransactionGroupRepository_ShouldThrowArgumentNullException()
    {
        // Act &amp; Assert
        var act = () =&gt; new TransactionGroupService(null!);
        act.Should().Throw&lt;ArgumentNullException&gt;()
            .And.ParamName.Should().Be(&quot;transactionGroupRepository&quot;);
    }

    #endregion

    #region GetByIdAsync Tests

    [Fact]
    public async Task GetByIdAsync_ExistingGroupOwnedByUser_ShouldReturnGroup()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;

        var expectedGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Vacation Trip&quot;,
            Description = &quot;Summer vacation expenses&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(expectedGroup);

        // Act
        var result = await _transactionGroupService.GetByIdAsync(groupId, userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Should().NotBeNull();
        result.Value.Id.Should().Be(groupId);
        result.Value.Name.Should().Be(&quot;Vacation Trip&quot;);
        result.Value.UserId.Should().Be(userId);

        _mockTransactionGroupRepository.Verify(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()), Times.Once);
    }

    [Fact]
    public async Task GetByIdAsync_ExistingGroupNotOwnedByUser_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int requestingUserId = 20; // Different user

        var group = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Other User&#39;s Group&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(group);

        // Act
        var result = await _transactionGroupService.GetByIdAsync(groupId, requestingUserId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);
    }

    [Fact]
    public async Task GetByIdAsync_NonExistentGroup_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 99999;
        const int userId = 10;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(TransactionGroupErrors.NotFound);

        // Act
        var result = await _transactionGroupService.GetByIdAsync(groupId, userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);
    }

    [Fact]
    public async Task GetByIdAsync_ShouldPassCancellationToken()
    {
        // Arrange
        using var cts = new CancellationTokenSource();
        var token = cts.Token;
        const int groupId = 1;
        const int userId = 10;

        var group = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Test&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, token))
            .ReturnsAsync(group);

        // Act
        await _transactionGroupService.GetByIdAsync(groupId, userId, token);

        // Assert
        _mockTransactionGroupRepository.Verify(r =&gt; r.GetByIdAsync(groupId, token), Times.Once);
    }

    #endregion

    #region GetByUserIdAsync Tests

    [Fact]
    public async Task GetByUserIdAsync_UserWithGroups_ShouldReturnGroups()
    {
        // Arrange
        const int userId = 10;

        var expectedGroups = new List&lt;TransactionGroup&gt;
        {
            new TransactionGroup { Id = 1, Name = &quot;Group A&quot;, UserId = userId, CreatedAt = DateTime.UtcNow },
            new TransactionGroup { Id = 2, Name = &quot;Group B&quot;, UserId = userId, CreatedAt = DateTime.UtcNow },
            new TransactionGroup { Id = 3, Name = &quot;Group C&quot;, UserId = userId, CreatedAt = DateTime.UtcNow }
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByUserIdAsync(userId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(expectedGroups);

        // Act
        var result = await _transactionGroupService.GetByUserIdAsync(userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Should().HaveCount(3);
        result.Value.Should().BeEquivalentTo(expectedGroups);

        _mockTransactionGroupRepository.Verify(r =&gt; r.GetByUserIdAsync(userId, It.IsAny&lt;CancellationToken&gt;()), Times.Once);
    }

    [Fact]
    public async Task GetByUserIdAsync_UserWithNoGroups_ShouldReturnEmptyList()
    {
        // Arrange
        const int userId = 10;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByUserIdAsync(userId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(new List&lt;TransactionGroup&gt;());

        // Act
        var result = await _transactionGroupService.GetByUserIdAsync(userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Should().NotBeNull();
        result.Value.Should().BeEmpty();
    }

    [Fact]
    public async Task GetByUserIdAsync_WhenRepositoryReturnsError_ShouldReturnError()
    {
        // Arrange
        const int userId = 10;
        var expectedError = Error.Failure(&quot;Database.Error&quot;, &quot;Failed to retrieve transaction groups&quot;);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByUserIdAsync(userId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(expectedError);

        // Act
        var result = await _transactionGroupService.GetByUserIdAsync(userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Should().Be(expectedError);
    }

    #endregion

    #region CreateAsync Tests

    [Fact]
    public async Task CreateAsync_ValidInput_ShouldCreateAndReturnGroup()
    {
        // Arrange
        const int userId = 10;
        const string name = &quot;New Project&quot;;
        const string description = &quot;Project description&quot;;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1; // Simulate ID assignment
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, name, description, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Should().NotBeNull();
        result.Value.Name.Should().Be(name);
        result.Value.Description.Should().Be(description);
        result.Value.UserId.Should().Be(userId);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.CreateAsync(It.Is&lt;TransactionGroup&gt;(g =&gt;
                g.Name == name &amp;&amp;
                g.Description == description &amp;&amp;
                g.UserId == userId),
                It.IsAny&lt;CancellationToken&gt;()),
            Times.Once);
    }

    [Fact]
    public async Task CreateAsync_WithNullDescription_ShouldCreateGroupWithNullDescription()
    {
        // Arrange
        const int userId = 10;
        const string name = &quot;No Description Group&quot;;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1;
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, name, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Description.Should().BeNull();
    }

    [Fact]
    public async Task CreateAsync_WithWhitespaceDescription_ShouldTrimToNull()
    {
        // Arrange
        const int userId = 10;
        const string name = &quot;Group Name&quot;;
        const string whitespaceDescription = &quot;   &quot;;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1;
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, name, whitespaceDescription, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Description.Should().BeNull();
    }

    [Theory]
    [InlineData(&quot;&quot;)]
    [InlineData(&quot;   &quot;)]
    [InlineData(null)]
    public async Task CreateAsync_WithEmptyOrWhitespaceName_ShouldReturnInvalidNameError(string? invalidName)
    {
        // Arrange
        const int userId = 10;

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, invalidName!, &quot;Description&quot;, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.Validation);
        result.FirstError.Code.Should().Be(&quot;Name&quot;);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task CreateAsync_WithNameTooLong_ShouldReturnInvalidNameError()
    {
        // Arrange
        const int userId = 10;
        var tooLongName = new string(&#39;A&#39;, 256); // 256 characters, limit is 255

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, tooLongName, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.Validation);
        result.FirstError.Code.Should().Be(&quot;Name&quot;);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task CreateAsync_WithNameAtMaxLength_ShouldSucceed()
    {
        // Arrange
        const int userId = 10;
        var maxLengthName = new string(&#39;A&#39;, 255); // Exactly 255 characters

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1;
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, maxLengthName, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Name.Should().Be(maxLengthName);
    }

    [Fact]
    public async Task CreateAsync_ShouldTrimName()
    {
        // Arrange
        const int userId = 10;
        const string nameWithWhitespace = &quot;  Trimmed Name  &quot;;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1;
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, nameWithWhitespace, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Name.Should().Be(&quot;Trimmed Name&quot;);
    }

    [Fact]
    public async Task CreateAsync_ShouldTrimDescription()
    {
        // Arrange
        const int userId = 10;
        const string name = &quot;Test Group&quot;;
        const string descriptionWithWhitespace = &quot;  Trimmed Description  &quot;;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt;
            {
                g.Id = 1;
                return g;
            });

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, name, descriptionWithWhitespace, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Description.Should().Be(&quot;Trimmed Description&quot;);
    }

    [Fact]
    public async Task CreateAsync_WhenRepositoryReturnsError_ShouldReturnError()
    {
        // Arrange
        const int userId = 10;
        var expectedError = Error.Failure(&quot;Database.Error&quot;, &quot;Failed to create transaction group&quot;);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.CreateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(expectedError);

        // Act
        var result = await _transactionGroupService.CreateAsync(userId, &quot;Valid Name&quot;, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Should().Be(expectedError);
    }

    #endregion

    #region UpdateAsync Tests

    [Fact]
    public async Task UpdateAsync_ValidInputOwnedByUser_ShouldUpdateAndReturnGroup()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;
        const string newName = &quot;Updated Name&quot;;
        const string newDescription = &quot;Updated Description&quot;;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Original Name&quot;,
            Description = &quot;Original Description&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt; g);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, newName, newDescription, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Name.Should().Be(newName);
        result.Value.Description.Should().Be(newDescription);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.UpdateAsync(It.Is&lt;TransactionGroup&gt;(g =&gt;
                g.Id == groupId &amp;&amp;
                g.Name == newName &amp;&amp;
                g.Description == newDescription),
                It.IsAny&lt;CancellationToken&gt;()),
            Times.Once);
    }

    [Fact]
    public async Task UpdateAsync_GroupNotOwnedByUser_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int requestingUserId = 20;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Other User&#39;s Group&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, requestingUserId, &quot;New Name&quot;, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task UpdateAsync_NonExistentGroup_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 99999;
        const int userId = 10;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(TransactionGroupErrors.NotFound);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, &quot;New Name&quot;, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Theory]
    [InlineData(&quot;&quot;)]
    [InlineData(&quot;   &quot;)]
    [InlineData(null)]
    public async Task UpdateAsync_WithEmptyOrWhitespaceName_ShouldReturnInvalidNameError(string? invalidName)
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Original&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, invalidName!, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.Validation);
        result.FirstError.Code.Should().Be(&quot;Name&quot;);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task UpdateAsync_WithNameTooLong_ShouldReturnInvalidNameError()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;
        var tooLongName = new string(&#39;A&#39;, 256);

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Original&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, tooLongName, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.Validation);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task UpdateAsync_CanSetDescriptionToNull()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Original&quot;,
            Description = &quot;Has Description&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt; g);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, &quot;New Name&quot;, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Description.Should().BeNull();
    }

    [Fact]
    public async Task UpdateAsync_ShouldTrimNameAndDescription()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Original&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.UpdateAsync(It.IsAny&lt;TransactionGroup&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync((TransactionGroup g, CancellationToken _) =&gt; g);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, userId, &quot;  Trimmed Name  &quot;, &quot;  Trimmed Description  &quot;, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Name.Should().Be(&quot;Trimmed Name&quot;);
        result.Value.Description.Should().Be(&quot;Trimmed Description&quot;);
    }

    #endregion

    #region DeleteAsync Tests

    [Fact]
    public async Task DeleteAsync_ValidGroupOwnedByUser_ShouldDeleteAndReturnDeleted()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;To Be Deleted&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.DeleteAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(Result.Deleted);

        // Act
        var result = await _transactionGroupService.DeleteAsync(groupId, userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeFalse();

        _mockTransactionGroupRepository.Verify(r =&gt; r.DeleteAsync(groupId, It.IsAny&lt;CancellationToken&gt;()), Times.Once);
    }

    [Fact]
    public async Task DeleteAsync_GroupNotOwnedByUser_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int requestingUserId = 20;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Other User&#39;s Group&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.DeleteAsync(groupId, requestingUserId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.DeleteAsync(It.IsAny&lt;int&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task DeleteAsync_NonExistentGroup_ShouldReturnNotFound()
    {
        // Arrange
        const int groupId = 99999;
        const int userId = 10;

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(TransactionGroupErrors.NotFound);

        // Act
        var result = await _transactionGroupService.DeleteAsync(groupId, userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);

        _mockTransactionGroupRepository.Verify(
            r =&gt; r.DeleteAsync(It.IsAny&lt;int&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Never);
    }

    [Fact]
    public async Task DeleteAsync_WhenRepositoryDeleteFails_ShouldReturnError()
    {
        // Arrange
        const int groupId = 1;
        const int userId = 10;
        var expectedError = Error.Failure(&quot;Database.Error&quot;, &quot;Failed to delete transaction group&quot;);

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Group&quot;,
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.DeleteAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(expectedError);

        // Act
        var result = await _transactionGroupService.DeleteAsync(groupId, userId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Should().Be(expectedError);
    }

    #endregion

    #region Authorization Tests

    [Fact]
    public async Task Authorization_GetByIdAsync_DifferentUser_ShouldNotExposeGroupExistence()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int attackerUserId = 20;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Secret Group&quot;,
            Description = &quot;Sensitive information&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.GetByIdAsync(groupId, attackerUserId, CancellationToken.None);

        // Assert
        // Should return NotFound to not leak information about existence
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);
    }

    [Fact]
    public async Task Authorization_UpdateAsync_DifferentUser_ShouldNotExposeGroupExistence()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int attackerUserId = 20;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Secret Group&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.UpdateAsync(groupId, attackerUserId, &quot;Hacked Name&quot;, null, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);
    }

    [Fact]
    public async Task Authorization_DeleteAsync_DifferentUser_ShouldNotExposeGroupExistence()
    {
        // Arrange
        const int groupId = 1;
        const int ownerUserId = 10;
        const int attackerUserId = 20;

        var existingGroup = new TransactionGroup
        {
            Id = groupId,
            Name = &quot;Secret Group&quot;,
            UserId = ownerUserId,
            CreatedAt = DateTime.UtcNow
        };

        _mockTransactionGroupRepository
            .Setup(r =&gt; r.GetByIdAsync(groupId, It.IsAny&lt;CancellationToken&gt;()))
            .ReturnsAsync(existingGroup);

        // Act
        var result = await _transactionGroupService.DeleteAsync(groupId, attackerUserId, CancellationToken.None);

        // Assert
        result.IsError.Should().BeTrue();
        result.FirstError.Type.Should().Be(ErrorType.NotFound);
    }

    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,5,17,42,1],[18,5,18,6,1],[19,9,19,83,1],[20,9,20,104,1],[21,5,21,6,1],[27,5,27,6,1],[29,9,29,25,1],[29,25,29,59,1],[29,59,29,60,1],[30,9,31,70,1],[32,5,32,6,1],[40,5,40,6,1],[45,9,52,11,1],[54,9,56,42,1],[59,9,59,107,1],[62,9,62,43,1],[63,9,63,43,1],[64,9,64,46,1],[65,9,65,56,1],[66,9,66,49,1],[68,9,68,121,1],[69,5,69,6,1],[73,5,73,6,1],[79,9,85,11,1],[87,9,89,34,1],[92,9,92,117,1],[95,9,95,42,1],[96,9,96,64,1],[97,5,97,6,1],[101,5,101,6,1],[106,9,108,60,1],[111,9,111,107,1],[114,9,114,42,1],[115,9,115,64,1],[116,5,116,6,1],[120,5,120,6,1],[122,9,122,55,1],[123,9,123,31,1],[127,9,133,11,1],[135,9,137,34,1],[140,9,140,77,1],[143,9,143,97,1],[144,5,144,6,1],[152,5,152,6,1],[156,9,161,11,1],[163,9,165,43,1],[168,9,168,102,1],[171,9,171,43,1],[172,9,172,44,1],[173,9,173,62,1],[175,9,175,124,1],[176,5,176,6,1],[180,5,180,6,1],[184,9,186,57,1],[189,9,189,102,1],[192,9,192,43,1],[193,9,193,43,1],[194,9,194,41,1],[195,5,195,6,1],[199,5,199,6,1],[202,9,202,102,1],[204,9,206,42,1],[209,9,209,102,1],[212,9,212,42,1],[213,9,213,54,1],[214,5,214,6,1],[222,5,222,6,1],[228,9,231,13,1],[231,13,231,14,1],[231,14,232,17,1],[232,17,232,26,1],[232,26,233,17,1],[233,17,233,26,1],[233,26,234,13,1],[234,13,234,14,1],[234,14,234,16,1],[237,9,237,116,1],[240,9,240,43,1],[241,9,241,43,1],[242,9,242,45,1],[243,9,243,59,1],[244,9,244,49,1],[246,9,252,25,1],[253,5,253,6,1],[257,5,257,6,1],[262,9,265,13,1],[265,13,265,14,1],[265,14,266,17,1],[266,17,266,26,1],[266,26,267,17,1],[267,17,267,26,1],[267,26,268,13,1],[268,13,268,14,1],[268,14,268,16,1],[271,9,271,109,1],[274,9,274,43,1],[275,9,275,52,1],[276,5,276,6,1],[280,5,280,6,1],[286,9,289,13,1],[289,13,289,14,1],[289,14,290,17,1],[290,17,290,26,1],[290,26,291,17,1],[291,17,291,26,1],[291,26,292,13,1],[292,13,292,14,1],[292,14,292,16,1],[295,9,295,126,1],[298,9,298,43,1],[299,9,299,52,1],[300,5,300,6,1],[307,5,307,6,1],[312,9,312,126,1],[315,9,315,42,1],[316,9,316,66,1],[317,9,317,52,1],[319,9,321,26,1],[322,5,322,6,1],[326,5,326,6,1],[329,9,329,48,1],[332,9,332,116,1],[335,9,335,42,1],[336,9,336,66,1],[337,9,337,52,1],[339,9,341,26,1],[342,5,342,6,1],[346,5,346,6,1],[349,9,349,50,1],[351,9,354,13,1],[354,13,354,14,1],[354,14,355,17,1],[355,17,355,26,1],[355,26,356,17,1],[356,17,356,26,1],[356,26,357,13,1],[357,13,357,14,1],[357,14,357,16,1],[360,9,360,118,1],[363,9,363,43,1],[364,9,364,54,1],[365,5,365,6,1],[369,5,369,6,1],[374,9,377,13,1],[377,13,377,14,1],[377,14,378,17,1],[378,17,378,26,1],[378,26,379,17,1],[379,17,379,26,1],[379,26,380,13,1],[380,13,380,14,1],[380,14,380,16,1],[383,9,383,123,1],[386,9,386,43,1],[387,9,387,55,1],[388,5,388,6,1],[392,5,392,6,1],[398,9,401,13,1],[401,13,401,14,1],[401,14,402,17,1],[402,17,402,26,1],[402,26,403,17,1],[403,17,403,26,1],[403,26,404,13,1],[404,13,404,14,1],[404,14,404,16,1],[407,9,407,130,1],[410,9,410,43,1],[411,9,411,69,1],[412,5,412,6,1],[416,5,416,6,1],[419,9,419,99,1],[421,9,423,42,1],[426,9,426,117,1],[429,9,429,42,1],[430,9,430,54,1],[431,5,431,6,1],[439,5,439,6,1],[446,9,453,11,1],[455,9,457,42,1],[459,9,461,72,1],[461,72,461,73,1],[461,73,461,75,1],[464,9,464,131,1],[467,9,467,43,1],[468,9,468,48,1],[469,9,469,62,1],[471,9,477,25,1],[478,5,478,6,1],[482,5,482,6,1],[488,9,494,11,1],[496,9,498,42,1],[501,9,501,134,1],[504,9,504,42,1],[505,9,505,64,1],[507,9,509,26,1],[510,5,510,6,1],[514,5,514,6,1],[519,9,521,60,1],[524,9,524,124,1],[527,9,527,42,1],[528,9,528,64,1],[530,9,532,26,1],[533,5,533,6,1],[540,5,540,6,1],[545,9,551,11,1],[553,9,555,42,1],[558,9,558,126,1],[561,9,561,42,1],[562,9,562,66,1],[563,9,563,52,1],[565,9,567,26,1],[568,5,568,6,1],[572,5,572,6,1],[576,9,576,48,1],[578,9,584,11,1],[586,9,588,42,1],[591,9,591,125,1],[594,9,594,42,1],[595,9,595,66,1],[597,9,599,26,1],[600,5,600,6,1],[604,5,604,6,1],[609,9,616,11,1],[618,9,620,42,1],[622,9,624,72,1],[624,72,624,73,1],[624,73,624,75,1],[627,9,627,124,1],[630,9,630,43,1],[631,9,631,52,1],[632,5,632,6,1],[636,5,636,6,1],[641,9,647,11,1],[649,9,651,42,1],[653,9,655,72,1],[655,72,655,73,1],[655,73,655,75,1],[658,9,658,153,1],[661,9,661,43,1],[662,9,662,55,1],[663,9,663,69,1],[664,5,664,6,1],[672,5,672,6,1],[677,9,683,11,1],[685,9,687,42,1],[689,9,691,43,1],[694,9,694,106,1],[697,9,697,43,1],[699,9,699,120,1],[700,5,700,6,1],[704,5,704,6,1],[710,9,716,11,1],[718,9,720,42,1],[723,9,723,116,1],[726,9,726,42,1],[727,9,727,64,1],[729,9,731,26,1],[732,5,732,6,1],[736,5,736,6,1],[741,9,743,60,1],[746,9,746,106,1],[749,9,749,42,1],[750,9,750,64,1],[752,9,754,26,1],[755,5,755,6,1],[759,5,759,6,1],[763,9,763,99,1],[765,9,771,11,1],[773,9,775,42,1],[777,9,779,42,1],[782,9,782,106,1],[785,9,785,42,1],[786,9,786,54,1],[787,5,787,6,1],[795,5,795,6,1],[801,9,808,11,1],[810,9,812,42,1],[815,9,815,115,1],[819,9,819,42,1],[820,9,820,64,1],[821,5,821,6,1],[825,5,825,6,1],[831,9,837,11,1],[839,9,841,42,1],[844,9,844,135,1],[847,9,847,42,1],[848,9,848,64,1],[849,5,849,6,1],[853,5,853,6,1],[859,9,865,11,1],[867,9,869,42,1],[872,9,872,114,1],[875,9,875,42,1],[876,9,876,64,1],[877,5,877,6,1]]);
    </script>
  </body>
</html>