<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/tests/ExpenseTrackerAPI.Application.Tests/Transactions/TransactionFilterParserTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using ErrorOr;
using ExpenseTrackerAPI.Contracts.Transactions;
using ExpenseTrackerAPI.Domain.Entities;
using FluentAssertions;
using Xunit;

namespace ExpenseTrackerAPI.Application.Tests.Transactions;

/// &lt;summary&gt;
/// Unit tests for TransactionFilterParser.
/// Tests validation logic for transaction filtering and query parameters.
/// &lt;/summary&gt;
public class TransactionFilterParserTests
{
    #region Null and Default Tests

    [Fact]
    public void Parse_WithNullRequest_ShouldReturnDefaultFilter()
    {
        // Act
        var result = TransactionFilterParser.Parse(null);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Should().NotBeNull();
        result.Value.TransactionType.Should().BeNull();
        result.Value.MinAmount.Should().BeNull();
        result.Value.MaxAmount.Should().BeNull();
        result.Value.DateFrom.Should().BeNull();
        result.Value.DateTo.Should().BeNull();
        result.Value.Page.Should().Be(1);
        result.Value.PageSize.Should().Be(20);
    }

    [Fact]
    public void Parse_WithEmptyRequest_ShouldReturnDefaultFilter()
    {
        // Arrange
        var request = new TransactionFilterRequest();

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionType.Should().BeNull();
        result.Value.Page.Should().Be(1);
        result.Value.PageSize.Should().Be(20);
    }

    #endregion

    #region Transaction Type Tests

    [Theory]
    [InlineData(&quot;EXPENSE&quot;, TransactionType.EXPENSE)]
    [InlineData(&quot;expense&quot;, TransactionType.EXPENSE)]
    [InlineData(&quot;Expense&quot;, TransactionType.EXPENSE)]
    [InlineData(&quot;INCOME&quot;, TransactionType.INCOME)]
    [InlineData(&quot;income&quot;, TransactionType.INCOME)]
    [InlineData(&quot;Income&quot;, TransactionType.INCOME)]
    public void Parse_WithValidTransactionType_ShouldParseCorrectly(string input, TransactionType expected)
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionType = input };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionType.Should().Be(expected);
    }

    [Theory]
    [InlineData(&quot;INVALID&quot;)]
    [InlineData(&quot;transfer&quot;)]
    [InlineData(&quot;123&quot;)]
    public void Parse_WithInvalidTransactionType_ShouldReturnValidationError(string input)
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionType = input };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Type.Should().Be(ErrorType.Validation);
        result.Errors[0].Code.Should().Be(&quot;TransactionType&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
    }

    [Fact]
    public void Parse_WithNullTransactionType_ShouldNotSetTransactionType()
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionType = null };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionType.Should().BeNull();
    }

    #endregion

    #region Amount Range Tests

    [Theory]
    [InlineData(0, 100)]
    [InlineData(10.50, 500.75)]
    [InlineData(0, 0)]
    [InlineData(100, 100)]
    public void Parse_WithValidAmountRange_ShouldParseCorrectly(decimal min, decimal max)
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            MinAmount = min,
            MaxAmount = max
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.MinAmount.Should().Be(min);
        result.Value.MaxAmount.Should().Be(max);
    }

    [Fact]
    public void Parse_WithNegativeMinAmount_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { MinAmount = -10.50m };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;MinAmount&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;negative&quot;);
    }

    [Fact]
    public void Parse_WithNegativeMaxAmount_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { MaxAmount = -50m };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;MaxAmount&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;negative&quot;);
    }

    [Fact]
    public void Parse_WithMinAmountGreaterThanMaxAmount_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            MinAmount = 100m,
            MaxAmount = 50m
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;AmountRange&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;greater than&quot;);
    }

    [Fact]
    public void Parse_WithOnlyMinAmount_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { MinAmount = 50m };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.MinAmount.Should().Be(50m);
        result.Value.MaxAmount.Should().BeNull();
    }

    [Fact]
    public void Parse_WithOnlyMaxAmount_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { MaxAmount = 200m };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.MinAmount.Should().BeNull();
        result.Value.MaxAmount.Should().Be(200m);
    }

    #endregion

    #region Date Range Tests

    [Theory]
    [InlineData(&quot;2024-01-01&quot;, &quot;2024-12-31&quot;)]
    [InlineData(&quot;2024-06-15&quot;, &quot;2024-06-15&quot;)]
    [InlineData(&quot;2020-01-01&quot;, &quot;2025-12-31&quot;)]
    public void Parse_WithValidDateRange_ShouldParseCorrectly(string from, string to)
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            DateFrom = from,
            DateTo = to
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.DateFrom.Should().Be(DateOnly.Parse(from));
        result.Value.DateTo.Should().Be(DateOnly.Parse(to));
    }

    [Theory]
    [InlineData(&quot;invalid-date&quot;)]
    [InlineData(&quot;2024/01/01&quot;)]
    [InlineData(&quot;01-01-2024&quot;)]
    [InlineData(&quot;2024-13-01&quot;)]
    [InlineData(&quot;2024-01-32&quot;)]
    [InlineData(&quot;abc&quot;)]
    public void Parse_WithInvalidDateFromFormat_ShouldReturnValidationError(string invalidDate)
    {
        // Arrange
        var request = new TransactionFilterRequest { DateFrom = invalidDate };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;DateFrom&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;Invalid date format&quot;);
    }

    [Theory]
    [InlineData(&quot;not-a-date&quot;)]
    [InlineData(&quot;12/31/2024&quot;)]
    [InlineData(&quot;2024.12.31&quot;)]
    public void Parse_WithInvalidDateToFormat_ShouldReturnValidationError(string invalidDate)
    {
        // Arrange
        var request = new TransactionFilterRequest { DateTo = invalidDate };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;DateTo&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
    }

    [Fact]
    public void Parse_WithDateFromAfterDateTo_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            DateFrom = &quot;2024-12-31&quot;,
            DateTo = &quot;2024-01-01&quot;
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;DateRange&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;cannot be after&quot;);
    }

    [Fact]
    public void Parse_WithOnlyDateFrom_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { DateFrom = &quot;2024-01-01&quot; };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.DateFrom.Should().Be(new DateOnly(2024, 1, 1));
        result.Value.DateTo.Should().BeNull();
    }

    [Fact]
    public void Parse_WithOnlyDateTo_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { DateTo = &quot;2024-12-31&quot; };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.DateFrom.Should().BeNull();
        result.Value.DateTo.Should().Be(new DateOnly(2024, 12, 31));
    }

    #endregion

    #region Payment Method Tests

    [Fact]
    public void Parse_WithValidPaymentMethods_Cash_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = new[] { &quot;CASH&quot; } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().NotBeNull();
        result.Value.PaymentMethods.Should().HaveCountGreaterThan(0);
    }

    [Fact]
    public void Parse_WithValidPaymentMethods_CaseInsensitive_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = new[] { &quot;cash&quot; } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().NotBeNull();
        result.Value.PaymentMethods.Should().HaveCountGreaterThan(0);
    }

    [Fact]
    public void Parse_WithValidPaymentMethods_BankTransfer_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = new[] { &quot;BANK_TRANSFER&quot; } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().NotBeNull();
        result.Value.PaymentMethods.Should().HaveCountGreaterThan(0);
    }

    [Fact]
    public void Parse_WithValidPaymentMethods_Multiple_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = new[] { &quot;CREDIT_CARD&quot;, &quot;CASH&quot; } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().NotBeNull();
        result.Value.PaymentMethods.Should().HaveCount(2);
    }

    [Fact]
    public void Parse_WithInvalidPaymentMethod_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            PaymentMethods = new[] { &quot;INVALID_METHOD&quot;, &quot;CASH&quot; }
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;PaymentMethods&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;Invalid payment method&quot;);
    }

    [Fact]
    public void Parse_WithNullPaymentMethods_ShouldNotSetPaymentMethods()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = null };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().BeNull();
    }

    [Fact]
    public void Parse_WithEmptyPaymentMethodsArray_ShouldNotSetPaymentMethods()
    {
        // Arrange
        var request = new TransactionFilterRequest { PaymentMethods = Array.Empty&lt;string&gt;() };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PaymentMethods.Should().BeNull();
    }

    #endregion

    #region Pagination Tests

    [Theory]
    [InlineData(1, 10)]
    [InlineData(1, 20)]
    [InlineData(5, 50)]
    [InlineData(100, 100)]
    public void Parse_WithValidPagination_ShouldParseCorrectly(int page, int pageSize)
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            Page = page,
            PageSize = pageSize
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Page.Should().Be(page);
        result.Value.PageSize.Should().Be(pageSize);
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(-100)]
    public void Parse_WithInvalidPageNumber_ShouldReturnValidationError(int page)
    {
        // Arrange
        var request = new TransactionFilterRequest { Page = page };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;Page&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;at least 1&quot;);
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(-50)]
    public void Parse_WithInvalidPageSize_ShouldReturnValidationError(int pageSize)
    {
        // Arrange
        var request = new TransactionFilterRequest { PageSize = pageSize };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;PageSize&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;at least 1&quot;);
    }

    [Fact]
    public void Parse_WithPageSizeExceedingMaximum_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { PageSize = 101 };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;PageSize&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;cannot exceed&quot;);
    }

    [Fact]
    public void Parse_WithPageSize100_ShouldBeValid()
    {
        // Arrange
        var request = new TransactionFilterRequest { PageSize = 100 };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.PageSize.Should().Be(100);
    }

    [Fact]
    public void Parse_WithNullPagination_ShouldUseDefaults()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            Page = null,
            PageSize = null
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Page.Should().Be(1);
        result.Value.PageSize.Should().Be(20);
    }

    #endregion

    #region Category and Group Tests

    [Fact]
    public void Parse_WithValidCategoryIds_Multiple_ShouldParseCorrectly()
    {
        // Arrange
        var categoryIds = new[] { 1, 2, 3 };
        var request = new TransactionFilterRequest { CategoryIds = categoryIds };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.CategoryIds.Should().NotBeNull();
        result.Value.CategoryIds.Should().BeEquivalentTo(categoryIds);
    }

    [Fact]
    public void Parse_WithValidCategoryIds_Single_ShouldParseCorrectly()
    {
        // Arrange
        var categoryIds = new[] { 100 };
        var request = new TransactionFilterRequest { CategoryIds = categoryIds };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.CategoryIds.Should().NotBeNull();
        result.Value.CategoryIds.Should().BeEquivalentTo(categoryIds);
    }

    [Fact]
    public void Parse_WithInvalidCategoryId_Zero_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { CategoryIds = new[] { 0 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;CategoryIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithInvalidCategoryId_Negative_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { CategoryIds = new[] { -1 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;CategoryIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithInvalidCategoryId_MixedValid_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { CategoryIds = new[] { 1, 2, -5 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;CategoryIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithValidTransactionGroupIds_Multiple_ShouldParseCorrectly()
    {
        // Arrange
        var groupIds = new[] { 1, 2, 3 };
        var request = new TransactionFilterRequest { TransactionGroupIds = groupIds };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionGroupIds.Should().NotBeNull();
        result.Value.TransactionGroupIds.Should().BeEquivalentTo(groupIds);
    }

    [Fact]
    public void Parse_WithValidTransactionGroupIds_Single_ShouldParseCorrectly()
    {
        // Arrange
        var groupIds = new[] { 50 };
        var request = new TransactionFilterRequest { TransactionGroupIds = groupIds };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionGroupIds.Should().NotBeNull();
        result.Value.TransactionGroupIds.Should().BeEquivalentTo(groupIds);
    }

    [Fact]
    public void Parse_WithInvalidTransactionGroupId_Zero_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionGroupIds = new[] { 0 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;TransactionGroupIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithInvalidTransactionGroupId_Negative_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionGroupIds = new[] { -10 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;TransactionGroupIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithInvalidTransactionGroupId_MixedValid_ShouldReturnValidationError()
    {
        // Arrange
        var request = new TransactionFilterRequest { TransactionGroupIds = new[] { 5, 10, -1 } };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;TransactionGroupIds&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;positive integers&quot;);
    }

    [Fact]
    public void Parse_WithUncategorizedFlag_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { Uncategorized = true };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Uncategorized.Should().BeTrue();
    }

    [Fact]
    public void Parse_WithUngroupedFlag_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { Ungrouped = true };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Ungrouped.Should().BeTrue();
    }

    #endregion

    #region Sorting Tests

    [Theory]
    [InlineData(&quot;date&quot;)]
    [InlineData(&quot;Date&quot;)]
    [InlineData(&quot;DATE&quot;)]
    [InlineData(&quot;amount&quot;)]
    [InlineData(&quot;subject&quot;)]
    [InlineData(&quot;paymentMethod&quot;)]
    [InlineData(&quot;payment_method&quot;)]
    [InlineData(&quot;createdAt&quot;)]
    [InlineData(&quot;created_at&quot;)]
    public void Parse_WithValidSortBy_ShouldParseCorrectly(string sortBy)
    {
        // Arrange
        var request = new TransactionFilterRequest { SortBy = sortBy };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.SortBy.Should().BeDefined();
    }

    [Theory]
    [InlineData(&quot;invalid&quot;)]
    [InlineData(&quot;user&quot;)]
    [InlineData(&quot;category&quot;)]
    [InlineData(&quot;123&quot;)]
    public void Parse_WithInvalidSortBy_ShouldReturnValidationError(string sortBy)
    {
        // Arrange
        var request = new TransactionFilterRequest { SortBy = sortBy };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;SortBy&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;Invalid sort field&quot;);
    }

    [Theory]
    [InlineData(&quot;asc&quot;, false)]
    [InlineData(&quot;ASC&quot;, false)]
    [InlineData(&quot;ascending&quot;, false)]
    [InlineData(&quot;desc&quot;, true)]
    [InlineData(&quot;DESC&quot;, true)]
    [InlineData(&quot;descending&quot;, true)]
    public void Parse_WithValidSortDirection_ShouldParseCorrectly(string direction, bool expectedDescending)
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            SortBy = &quot;date&quot;,
            SortDirection = direction
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.SortDescending.Should().Be(expectedDescending);
    }

    [Theory]
    [InlineData(&quot;invalid&quot;)]
    [InlineData(&quot;up&quot;)]
    [InlineData(&quot;down&quot;)]
    [InlineData(&quot;123&quot;)]
    public void Parse_WithInvalidSortDirection_ShouldReturnValidationError(string direction)
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            SortBy = &quot;date&quot;,
            SortDirection = direction
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().ContainSingle();
        result.Errors[0].Code.Should().Be(&quot;SortDirection&quot;);
        result.Errors[0].Code.Should().NotContain(&quot;.&quot;);
        result.Errors[0].Description.Should().Contain(&quot;Invalid sort direction&quot;);
    }

    #endregion

    #region Text Search Tests

    [Theory]
    [InlineData(&quot;grocery&quot;)]
    [InlineData(&quot;Salary payment&quot;)]
    [InlineData(&quot;Coffee at Starbucks&quot;)]
    public void Parse_WithSubjectContains_ShouldParseCorrectly(string subject)
    {
        // Arrange
        var request = new TransactionFilterRequest { SubjectContains = subject };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.SubjectContains.Should().Be(subject.Trim());
    }

    [Theory]
    [InlineData(&quot;Important note&quot;)]
    [InlineData(&quot;Meeting expenses&quot;)]
    public void Parse_WithNotesContains_ShouldParseCorrectly(string notes)
    {
        // Arrange
        var request = new TransactionFilterRequest { NotesContains = notes };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.NotesContains.Should().Be(notes.Trim());
    }

    [Fact]
    public void Parse_WithWhitespaceSubject_ShouldSetToNull()
    {
        // Arrange
        var request = new TransactionFilterRequest { SubjectContains = &quot;   &quot; };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.SubjectContains.Should().BeNull();
    }

    #endregion

    #region Multiple Errors Tests

    [Fact]
    public void Parse_WithMultipleValidationErrors_ShouldReturnAllErrors()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            TransactionType = &quot;INVALID&quot;,
            MinAmount = -50m,
            MaxAmount = -100m,
            Page = 0,
            PageSize = 0
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().HaveCountGreaterThan(1);
        result.Errors.Should().OnlyContain(e =&gt; !e.Code.Contains(&quot;.&quot;),
            &quot;error keys should not contain dots&quot;);
    }

    [Fact]
    public void Parse_WithAllInvalidFields_ShouldReturnMultipleErrors()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            TransactionType = &quot;INVALID_TYPE&quot;,
            MinAmount = 200m,
            MaxAmount = 100m,
            DateFrom = &quot;invalid-date&quot;,
            DateTo = &quot;2024-12-31&quot;,
            Page = -1,
            PageSize = 200,
            PaymentMethods = new[] { &quot;INVALID_METHOD&quot; },
            CategoryIds = new[] { 0, -1 },
            SortBy = &quot;invalid_field&quot;
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeTrue();
        result.Errors.Should().HaveCountGreaterThan(5);

        // Verify no error keys contain dots
        foreach (var error in result.Errors)
        {
            error.Code.Should().NotContain(&quot;.&quot;, $&quot;Error code &#39;{error.Code}&#39; should not contain dots&quot;);
        }
    }

    #endregion

    #region Complex Filter Tests

    [Fact]
    public void Parse_WithCompleteValidFilter_ShouldParseAllFieldsCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            TransactionType = &quot;EXPENSE&quot;,
            MinAmount = 10m,
            MaxAmount = 500m,
            DateFrom = &quot;2024-01-01&quot;,
            DateTo = &quot;2024-12-31&quot;,
            SubjectContains = &quot;grocery&quot;,
            NotesContains = &quot;weekly shopping&quot;,
            PaymentMethods = new[] { &quot;CASH&quot;, &quot;CREDIT_CARD&quot; },
            CategoryIds = new[] { 1, 2, 3 },
            TransactionGroupIds = new[] { 5 },
            Uncategorized = false,
            Ungrouped = false,
            SortBy = &quot;date&quot;,
            SortDirection = &quot;desc&quot;,
            Page = 2,
            PageSize = 50
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.TransactionType.Should().Be(TransactionType.EXPENSE);
        result.Value.MinAmount.Should().Be(10m);
        result.Value.MaxAmount.Should().Be(500m);
        result.Value.DateFrom.Should().Be(new DateOnly(2024, 1, 1));
        result.Value.DateTo.Should().Be(new DateOnly(2024, 12, 31));
        result.Value.SubjectContains.Should().Be(&quot;grocery&quot;);
        result.Value.NotesContains.Should().Be(&quot;weekly shopping&quot;);
        result.Value.PaymentMethods.Should().HaveCount(2);
        result.Value.CategoryIds.Should().HaveCount(3);
        result.Value.TransactionGroupIds.Should().HaveCount(1);
        result.Value.Uncategorized.Should().BeFalse();
        result.Value.Ungrouped.Should().BeFalse();
        result.Value.SortDescending.Should().BeTrue();
        result.Value.Page.Should().Be(2);
        result.Value.PageSize.Should().Be(50);
    }

    #endregion

    #region Edge Cases

    [Fact]
    public void Parse_WithVeryLargePageNumber_ShouldParseCorrectly()
    {
        // Arrange
        var request = new TransactionFilterRequest { Page = 999999 };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.Page.Should().Be(999999);
    }

    [Fact]
    public void Parse_WithZeroAmounts_ShouldBeValid()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            MinAmount = 0m,
            MaxAmount = 0m
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.MinAmount.Should().Be(0m);
        result.Value.MaxAmount.Should().Be(0m);
    }

    [Fact]
    public void Parse_WithSameDateFromAndTo_ShouldBeValid()
    {
        // Arrange
        var request = new TransactionFilterRequest
        {
            DateFrom = &quot;2024-06-15&quot;,
            DateTo = &quot;2024-06-15&quot;
        };

        // Act
        var result = TransactionFilterParser.Parse(request);

        // Assert
        result.IsError.Should().BeFalse();
        result.Value.DateFrom.Should().Be(result.Value.DateTo);
    }

    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[19,5,19,6,1],[21,9,21,58,1],[24,9,24,43,1],[25,9,25,43,1],[26,9,26,56,1],[27,9,27,50,1],[28,9,28,50,1],[29,9,29,49,1],[30,9,30,47,1],[31,9,31,42,1],[32,9,32,47,1],[33,5,33,6,1],[37,5,37,6,1],[39,9,39,54,1],[42,9,42,61,1],[45,9,45,43,1],[46,9,46,56,1],[47,9,47,42,1],[48,9,48,47,1],[49,5,49,6,1],[63,5,63,6,1],[65,9,65,80,1],[68,9,68,61,1],[71,9,71,43,1],[72,9,72,60,1],[73,5,73,6,1],[80,5,80,6,1],[82,9,82,80,1],[85,9,85,61,1],[88,9,88,42,1],[89,9,89,48,1],[90,9,90,65,1],[91,9,91,62,1],[92,9,92,56,1],[93,5,93,6,1],[97,5,97,6,1],[99,9,99,79,1],[102,9,102,61,1],[105,9,105,43,1],[106,9,106,56,1],[107,5,107,6,1],[119,5,119,6,1],[121,9,125,11,1],[128,9,128,61,1],[131,9,131,43,1],[132,9,132,49,1],[133,9,133,49,1],[134,5,134,6,1],[138,5,138,6,1],[140,9,140,76,1],[143,9,143,61,1],[146,9,146,42,1],[147,9,147,48,1],[148,9,148,56,1],[149,9,149,56,1],[150,9,150,67,1],[151,5,151,6,1],[155,5,155,6,1],[157,9,157,73,1],[160,9,160,61,1],[163,9,163,42,1],[164,9,164,48,1],[165,9,165,56,1],[166,9,166,56,1],[167,9,167,67,1],[168,5,168,6,1],[172,5,172,6,1],[174,9,178,11,1],[181,9,181,61,1],[184,9,184,42,1],[185,9,185,48,1],[186,9,186,58,1],[187,9,187,56,1],[188,9,188,71,1],[189,5,189,6,1],[193,5,193,6,1],[195,9,195,72,1],[198,9,198,61,1],[201,9,201,43,1],[202,9,202,49,1],[203,9,203,50,1],[204,5,204,6,1],[208,5,208,6,1],[210,9,210,73,1],[213,9,213,61,1],[216,9,216,43,1],[217,9,217,50,1],[218,9,218,50,1],[219,5,219,6,1],[230,5,230,6,1],[232,9,236,11,1],[239,9,239,61,1],[242,9,242,43,1],[243,9,243,65,1],[244,9,244,61,1],[245,5,245,6,1],[255,5,255,6,1],[257,9,257,79,1],[260,9,260,61,1],[263,9,263,42,1],[264,9,264,48,1],[265,9,265,55,1],[266,9,266,56,1],[267,9,267,78,1],[268,5,268,6,1],[275,5,275,6,1],[277,9,277,77,1],[280,9,280,61,1],[283,9,283,42,1],[284,9,284,48,1],[285,9,285,53,1],[286,9,286,56,1],[287,5,287,6,1],[291,5,291,6,1],[293,9,297,11,1],[300,9,300,61,1],[303,9,303,42,1],[304,9,304,48,1],[305,9,305,56,1],[306,9,306,56,1],[307,9,307,74,1],[308,5,308,6,1],[312,5,312,6,1],[314,9,314,80,1],[317,9,317,61,1],[320,9,320,43,1],[321,9,321,69,1],[322,9,322,47,1],[323,5,323,6,1],[327,5,327,6,1],[329,9,329,78,1],[332,9,332,61,1],[335,9,335,43,1],[336,9,336,49,1],[337,9,337,69,1],[338,5,338,6,1],[346,5,346,6,1],[348,9,348,90,1],[351,9,351,61,1],[354,9,354,43,1],[355,9,355,58,1],[356,9,356,70,1],[357,5,357,6,1],[361,5,361,6,1],[363,9,363,90,1],[366,9,366,61,1],[369,9,369,43,1],[370,9,370,58,1],[371,9,371,70,1],[372,5,372,6,1],[376,5,376,6,1],[378,9,378,99,1],[381,9,381,61,1],[384,9,384,43,1],[385,9,385,58,1],[386,9,386,70,1],[387,5,387,6,1],[391,5,391,6,1],[393,9,393,105,1],[396,9,396,61,1],[399,9,399,43,1],[400,9,400,58,1],[401,9,401,59,1],[402,5,402,6,1],[406,5,406,6,1],[408,9,411,11,1],[414,9,414,61,1],[417,9,417,42,1],[418,9,418,48,1],[419,9,419,61,1],[420,9,420,56,1],[421,9,421,81,1],[422,5,422,6,1],[426,5,426,6,1],[428,9,428,78,1],[431,9,431,61,1],[434,9,434,43,1],[435,9,435,55,1],[436,5,436,6,1],[440,5,440,6,1],[442,9,442,95,1],[445,9,445,61,1],[448,9,448,43,1],[449,9,449,55,1],[450,5,450,6,1],[462,5,462,6,1],[464,9,468,11,1],[471,9,471,61,1],[474,9,474,43,1],[475,9,475,45,1],[476,9,476,53,1],[477,5,477,6,1],[484,5,484,6,1],[486,9,486,68,1],[489,9,489,61,1],[492,9,492,42,1],[493,9,493,48,1],[494,9,494,51,1],[495,9,495,56,1],[496,9,496,69,1],[497,5,497,6,1],[504,5,504,6,1],[506,9,506,76,1],[509,9,509,61,1],[512,9,512,42,1],[513,9,513,48,1],[514,9,514,55,1],[515,9,515,56,1],[516,9,516,69,1],[517,5,517,6,1],[521,5,521,6,1],[523,9,523,71,1],[526,9,526,61,1],[529,9,529,42,1],[530,9,530,48,1],[531,9,531,55,1],[532,9,532,56,1],[533,9,533,72,1],[534,5,534,6,1],[538,5,538,6,1],[540,9,540,71,1],[543,9,543,61,1],[546,9,546,43,1],[547,9,547,48,1],[548,5,548,6,1],[552,5,552,6,1],[554,9,558,11,1],[561,9,561,61,1],[564,9,564,43,1],[565,9,565,42,1],[566,9,566,47,1],[567,5,567,6,1],[575,5,575,6,1],[577,9,577,45,1],[578,9,578,82,1],[581,9,581,61,1],[584,9,584,43,1],[585,9,585,55,1],[586,9,586,71,1],[587,5,587,6,1],[591,5,591,6,1],[593,9,593,41,1],[594,9,594,82,1],[597,9,597,61,1],[600,9,600,43,1],[601,9,601,55,1],[602,9,602,71,1],[603,5,603,6,1],[607,5,607,6,1],[609,9,609,82,1],[612,9,612,61,1],[615,9,615,42,1],[616,9,616,48,1],[617,9,617,58,1],[618,9,618,56,1],[619,9,619,76,1],[620,5,620,6,1],[624,5,624,6,1],[626,9,626,83,1],[629,9,629,61,1],[632,9,632,42,1],[633,9,633,48,1],[634,9,634,58,1],[635,9,635,56,1],[636,9,636,76,1],[637,5,637,6,1],[641,5,641,6,1],[643,9,643,89,1],[646,9,646,61,1],[649,9,649,42,1],[650,9,650,48,1],[651,9,651,58,1],[652,9,652,56,1],[653,9,653,76,1],[654,5,654,6,1],[658,5,658,6,1],[660,9,660,42,1],[661,9,661,87,1],[664,9,664,61,1],[667,9,667,43,1],[668,9,668,63,1],[669,9,669,76,1],[670,5,670,6,1],[674,5,674,6,1],[676,9,676,37,1],[677,9,677,87,1],[680,9,680,61,1],[683,9,683,43,1],[684,9,684,63,1],[685,9,685,76,1],[686,5,686,6,1],[690,5,690,6,1],[692,9,692,90,1],[695,9,695,61,1],[698,9,698,42,1],[699,9,699,48,1],[700,9,700,66,1],[701,9,701,56,1],[702,9,702,76,1],[703,5,703,6,1],[707,5,707,6,1],[709,9,709,92,1],[712,9,712,61,1],[715,9,715,42,1],[716,9,716,48,1],[717,9,717,66,1],[718,9,718,56,1],[719,9,719,76,1],[720,5,720,6,1],[724,5,724,6,1],[726,9,726,98,1],[729,9,729,61,1],[732,9,732,42,1],[733,9,733,48,1],[734,9,734,66,1],[735,9,735,56,1],[736,9,736,76,1],[737,5,737,6,1],[741,5,741,6,1],[743,9,743,77,1],[746,9,746,61,1],[749,9,749,43,1],[750,9,750,54,1],[751,5,751,6,1],[755,5,755,6,1],[757,9,757,73,1],[760,9,760,61,1],[763,9,763,43,1],[764,9,764,50,1],[765,5,765,6,1],[782,5,782,6,1],[784,9,784,72,1],[787,9,787,61,1],[790,9,790,43,1],[791,9,791,50,1],[792,5,792,6,1],[800,5,800,6,1],[802,9,802,72,1],[805,9,805,61,1],[808,9,808,42,1],[809,9,809,48,1],[810,9,810,53,1],[811,9,811,56,1],[812,9,812,77,1],[813,5,813,6,1],[823,5,823,6,1],[825,9,829,11,1],[832,9,832,61,1],[835,9,835,43,1],[836,9,836,69,1],[837,5,837,6,1],[845,5,845,6,1],[847,9,851,11,1],[854,9,854,61,1],[857,9,857,42,1],[858,9,858,48,1],[859,9,859,60,1],[860,9,860,56,1],[861,9,861,81,1],[862,5,862,6,1],[873,5,873,6,1],[875,9,875,82,1],[878,9,878,61,1],[881,9,881,43,1],[882,9,882,66,1],[883,5,883,6,1],[889,5,889,6,1],[891,9,891,78,1],[894,9,894,61,1],[897,9,897,43,1],[898,9,898,62,1],[899,5,899,6,1],[903,5,903,6,1],[905,9,905,80,1],[908,9,908,61,1],[911,9,911,43,1],[912,9,912,56,1],[913,5,913,6,1],[921,5,921,6,1],[923,9,930,11,1],[933,9,933,61,1],[936,9,936,42,1],[937,9,937,56,1],[938,9,939,51,1],[940,5,940,6,1],[944,5,944,6,1],[946,9,958,11,1],[961,9,961,61,1],[964,9,964,42,1],[965,9,965,56,1],[968,9,968,16,1],[968,18,968,27,1],[968,28,968,30,1],[968,31,968,44,1],[969,9,969,10,1],[970,13,970,103,1],[971,9,971,10,1],[972,5,972,6,1],[980,5,980,6,1],[982,9,1000,11,1],[1003,9,1003,61,1],[1006,9,1006,43,1],[1007,9,1007,75,1],[1008,9,1008,49,1],[1009,9,1009,50,1],[1010,9,1010,69,1],[1011,9,1011,69,1],[1012,9,1012,61,1],[1013,9,1013,67,1],[1014,9,1014,59,1],[1015,9,1015,56,1],[1016,9,1016,64,1],[1017,9,1017,55,1],[1018,9,1018,51,1],[1019,9,1019,55,1],[1020,9,1020,42,1],[1021,9,1021,47,1],[1022,5,1022,6,1],[1030,5,1030,6,1],[1032,9,1032,70,1],[1035,9,1035,61,1],[1038,9,1038,43,1],[1039,9,1039,47,1],[1040,5,1040,6,1],[1044,5,1044,6,1],[1046,9,1050,11,1],[1053,9,1053,61,1],[1056,9,1056,43,1],[1057,9,1057,48,1],[1058,9,1058,48,1],[1059,5,1059,6,1],[1063,5,1063,6,1],[1065,9,1069,11,1],[1072,9,1072,61,1],[1075,9,1075,43,1],[1076,9,1076,64,1],[1077,5,1077,6,1]]);
    </script>
  </body>
</html>