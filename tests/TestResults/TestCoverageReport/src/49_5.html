<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/src/ExpenseTrackerAPI.WebApi/Controllers/V1/TransactionController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Microsoft.AspNetCore.Mvc;
using ExpenseTrackerAPI.Application.Transactions.Interfaces.Application;
using ExpenseTrackerAPI.Contracts.Transactions;
using Microsoft.AspNetCore.Authorization;
using Asp.Versioning;
using ExpenseTrackerAPI.Domain.Errors;

namespace ExpenseTrackerAPI.WebApi.Controllers.V1;

/// &lt;summary&gt;
/// Transaction management endpoints for API version 1.0.
/// &lt;/summary&gt;
[ApiController]
[Route(&quot;api/v{version:apiVersion}/transactions&quot;)]
[ApiVersion(&quot;1.0&quot;)]
[Authorize]
public class TransactionController : ApiControllerBase
{
    private readonly ITransactionService _transactionService;
    private readonly ILogger&lt;TransactionController&gt; _logger;

    /// &lt;summary&gt;
    /// Initializes a new instance of the TransactionController class.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transactionService&quot;&gt;Transaction service&lt;/param&gt;
    /// &lt;param name=&quot;logger&quot;&gt;Logger instance&lt;/param&gt;
    public TransactionController(
        ITransactionService transactionService,
        ILogger&lt;TransactionController&gt; logger)
    {
        _transactionService = transactionService ?? throw new ArgumentNullException(nameof(transactionService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// &lt;summary&gt;
    /// Get transactions for the authenticated user with optional filtering, sorting, and pagination.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transactionType&quot;&gt;Filter by type: EXPENSE or INCOME&lt;/param&gt;
    /// &lt;param name=&quot;minAmount&quot;&gt;Filter by minimum amount (inclusive)&lt;/param&gt;
    /// &lt;param name=&quot;maxAmount&quot;&gt;Filter by maximum amount (inclusive)&lt;/param&gt;
    /// &lt;param name=&quot;dateFrom&quot;&gt;Filter by start date (yyyy-MM-dd format, inclusive)&lt;/param&gt;
    /// &lt;param name=&quot;dateTo&quot;&gt;Filter by end date (yyyy-MM-dd format, inclusive)&lt;/param&gt;
    /// &lt;param name=&quot;subjectContains&quot;&gt;Filter by subject containing text (case-insensitive)&lt;/param&gt;
    /// &lt;param name=&quot;notesContains&quot;&gt;Filter by notes containing text (case-insensitive)&lt;/param&gt;
    /// &lt;param name=&quot;paymentMethods&quot;&gt;Filter by payment methods (comma-separated: CASH,DEBIT_CARD,CREDIT_CARD,BANK_TRANSFER,MOBILE_PAYMENT,PAYPAL,CRYPTO,OTHER)&lt;/param&gt;
    /// &lt;param name=&quot;categoryIds&quot;&gt;Filter by category IDs (comma-separated)&lt;/param&gt;
    /// &lt;param name=&quot;uncategorized&quot;&gt;Filter for uncategorized transactions only&lt;/param&gt;
    /// &lt;param name=&quot;transactionGroupIds&quot;&gt;Filter by transaction group IDs (comma-separated)&lt;/param&gt;
    /// &lt;param name=&quot;ungrouped&quot;&gt;Filter for ungrouped transactions only&lt;/param&gt;
    /// &lt;param name=&quot;sortBy&quot;&gt;Sort field: date, amount, subject, paymentMethod, createdAt, updatedAt (default: date)&lt;/param&gt;
    /// &lt;param name=&quot;sortDirection&quot;&gt;Sort direction: asc or desc (default: desc)&lt;/param&gt;
    /// &lt;param name=&quot;page&quot;&gt;Page number, 1-based (default: 1)&lt;/param&gt;
    /// &lt;param name=&quot;pageSize&quot;&gt;Items per page, max 100 (default: 20)&lt;/param&gt;
    /// &lt;param name=&quot;cancellationToken&quot;&gt;Cancellation token&lt;/param&gt;
    /// &lt;returns&gt;Paginated list of transactions matching the filter criteria&lt;/returns&gt;
    /// &lt;response code=&quot;200&quot;&gt;Transactions retrieved successfully&lt;/response&gt;
    /// &lt;response code=&quot;400&quot;&gt;Invalid filter parameters&lt;/response&gt;
    /// &lt;response code=&quot;401&quot;&gt;User not authenticated&lt;/response&gt;
    [HttpGet]
    [ProducesResponseType(typeof(TransactionFilterResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]
    public async Task&lt;IActionResult&gt; GetTransactions(
        [FromQuery] string? transactionType = null,
        [FromQuery] decimal? minAmount = null,
        [FromQuery] decimal? maxAmount = null,
        [FromQuery] string? dateFrom = null,
        [FromQuery] string? dateTo = null,
        [FromQuery] string? subjectContains = null,
        [FromQuery] string? notesContains = null,
        [FromQuery] string? paymentMethods = null,
        [FromQuery] string? categoryIds = null,
        [FromQuery] bool? uncategorized = null,
        [FromQuery] string? transactionGroupIds = null,
        [FromQuery] bool? ungrouped = null,
        [FromQuery] string? sortBy = null,
        [FromQuery] string? sortDirection = null,
        [FromQuery] int? page = null,
        [FromQuery] int? pageSize = null,
        CancellationToken cancellationToken = default)
    {
        var unauthorizedResult = CheckUserContext();
        if (unauthorizedResult != null) return unauthorizedResult;

        var userId = GetRequiredUserId();

        // Build filter request from query parameters
        var filterRequest = new TransactionFilterRequest
        {
            TransactionType = transactionType,
            MinAmount = minAmount,
            MaxAmount = maxAmount,
            DateFrom = dateFrom,
            DateTo = dateTo,
            SubjectContains = subjectContains,
            NotesContains = notesContains,
            PaymentMethods = ParseCommaSeparatedArray(paymentMethods),
            CategoryIds = ParseCommaSeparatedIntArray(categoryIds),
            Uncategorized = uncategorized,
            TransactionGroupIds = ParseCommaSeparatedIntArray(transactionGroupIds),
            Ungrouped = ungrouped,
            SortBy = sortBy,
            SortDirection = sortDirection,
            Page = page,
            PageSize = pageSize
        };

        // Parse and validate the filter request
        var parseResult = TransactionFilterParser.Parse(filterRequest);
        if (parseResult.IsError)
        {
            _logger.LogWarning(&quot;Invalid filter parameters for user {UserId}: {Errors}&quot;,
                userId, string.Join(&quot;, &quot;, parseResult.Errors.Select(e =&gt; e.Description)));
            return Problem(parseResult.Errors);
        }

        var filter = parseResult.Value;

        var result = await _transactionService.GetByUserIdWithFilterAsync(userId, filter, cancellationToken);

        if (result.IsError)
        {
            _logger.LogWarning(&quot;Failed to get transactions for user {UserId}: {Errors}&quot;,
                userId, string.Join(&quot;, &quot;, result.Errors.Select(e =&gt; e.Description)));
            return Problem(result.Errors);
        }

        return Ok(result.Value);
    }

    /// &lt;summary&gt;
    /// Get a specific transaction by ID.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot;&gt;Transaction ID&lt;/param&gt;
    /// &lt;param name=&quot;cancellationToken&quot;&gt;Cancellation token&lt;/param&gt;
    /// &lt;returns&gt;Transaction details&lt;/returns&gt;
    /// &lt;response code=&quot;200&quot;&gt;Transaction retrieved successfully&lt;/response&gt;
    /// &lt;response code=&quot;401&quot;&gt;User not authenticated&lt;/response&gt;
    /// &lt;response code=&quot;404&quot;&gt;Transaction not found&lt;/response&gt;
    /// &lt;response code=&quot;500&quot;&gt;Internal server error&lt;/response&gt;
    [HttpGet(&quot;{id:int}&quot;)]
    [ProducesResponseType(typeof(TransactionResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
    public async Task&lt;IActionResult&gt; GetTransaction(int id, CancellationToken cancellationToken = default)
    {
        if (id &lt;= 0)
        {
            _logger.LogWarning(&quot;Invalid transaction ID {TransactionId} provided by user {UserId}&quot;, id, GetUserId());
            return Problem(TransactionErrors.InvalidTransactionId);
        }

        var unauthorizedResult = CheckUserContext();
        if (unauthorizedResult != null) return unauthorizedResult;
        var userId = GetRequiredUserId();
        var result = await _transactionService.GetByIdAsync(id, cancellationToken);

        if (result.IsError)
        {
            _logger.LogWarning(&quot;Failed to get transaction {TransactionId} for user {UserId}: {Errors}&quot;,
                id, userId, string.Join(&quot;, &quot;, result.Errors.Select(e =&gt; e.Description)));
            return Problem(result.Errors);
        }

        var transaction = result.Value;
        return Ok(transaction.ToResponse());
    }

    /// &lt;summary&gt;
    /// Create a new transaction for the authenticated user.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;request&quot;&gt;Transaction creation request&lt;/param&gt;
    /// &lt;param name=&quot;cancellationToken&quot;&gt;Cancellation token&lt;/param&gt;
    /// &lt;returns&gt;Created transaction&lt;/returns&gt;
    /// &lt;response code=&quot;201&quot;&gt;Transaction created successfully&lt;/response&gt;
    /// &lt;response code=&quot;400&quot;&gt;Invalid request data&lt;/response&gt;
    /// &lt;response code=&quot;401&quot;&gt;User not authenticated&lt;/response&gt;
    /// &lt;response code=&quot;404&quot;&gt;Referenced entity not found (user, category, etc.)&lt;/response&gt;
    [HttpPost]
    [ProducesResponseType(typeof(TransactionResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
    public async Task&lt;IActionResult&gt; CreateTransaction(
        [FromBody] CreateTransactionRequest request,
        CancellationToken cancellationToken = default)
    {
        var unauthorizedResult = CheckUserContext();
        if (unauthorizedResult != null) return unauthorizedResult;

        var userId = GetRequiredUserId();

        // Parse and validate string values to enums
        var parseResult = TransactionRequestParser.ParseCreateRequest(request);
        if (parseResult.IsError)
        {
            _logger.LogWarning(&quot;Invalid transaction request for user {UserId}: {Errors}&quot;,
                userId, string.Join(&quot;, &quot;, parseResult.Errors.Select(e =&gt; e.Description)));
            return Problem(parseResult.Errors);
        }

        var (transactionType, paymentMethod) = parseResult.Value;

        var result = await _transactionService.CreateAsync(
            userId: userId,
            transactionType: transactionType,
            amount: request.Amount,
            date: request.Date,
            subject: request.Subject,
            notes: request.Notes,
            paymentMethod: paymentMethod,
            categoryId: request.CategoryId,
            transactionGroupId: request.TransactionGroupId,
            cancellationToken: cancellationToken);

        if (result.IsError)
        {
            _logger.LogWarning(&quot;Failed to create transaction for user {UserId}: {Errors}&quot;,
                userId, string.Join(&quot;, &quot;, result.Errors.Select(e =&gt; e.Description)));
            return Problem(result.Errors);
        }

        var transaction = result.Value;
        return CreatedAtAction(nameof(GetTransaction), new { id = transaction.Id, version = &quot;1.0&quot; }, transaction.ToResponse());
    }

    /// &lt;summary&gt;
    /// Update an existing transaction.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot;&gt;Transaction ID to update&lt;/param&gt;
    /// &lt;param name=&quot;request&quot;&gt;Transaction update request&lt;/param&gt;
    /// &lt;param name=&quot;cancellationToken&quot;&gt;Cancellation token&lt;/param&gt;
    /// &lt;returns&gt;Updated transaction&lt;/returns&gt;
    /// &lt;response code=&quot;200&quot;&gt;Transaction updated successfully&lt;/response&gt;
    /// &lt;response code=&quot;400&quot;&gt;Invalid request data&lt;/response&gt;
    /// &lt;response code=&quot;401&quot;&gt;User not authenticated&lt;/response&gt;
    /// &lt;response code=&quot;404&quot;&gt;Transaction not found or referenced entity not found&lt;/response&gt;
    [HttpPut(&quot;{id:int}&quot;)]
    [ProducesResponseType(typeof(TransactionResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
    public async Task&lt;IActionResult&gt; UpdateTransaction(
        int id,
        [FromBody] UpdateTransactionRequest request,
        CancellationToken cancellationToken = default)
    {
        if (id &lt;= 0)
        {
            _logger.LogWarning(&quot;Invalid transaction ID {TransactionId} provided by user {UserId}&quot;, id, GetUserId());
            return Problem(TransactionErrors.InvalidTransactionId);
        }

        var unauthorizedResult = CheckUserContext();
        if (unauthorizedResult != null) return unauthorizedResult;

        var userId = GetRequiredUserId();

        // Parse and validate string values to enums
        var parseResult = TransactionRequestParser.ParseUpdateRequest(request);
        if (parseResult.IsError)
        {
            _logger.LogWarning(&quot;Invalid transaction update request for user {UserId}: {Errors}&quot;,
                userId, string.Join(&quot;, &quot;, parseResult.Errors.Select(e =&gt; e.Description)));
            return Problem(parseResult.Errors);
        }

        var (transactionType, paymentMethod) = parseResult.Value;

        var result = await _transactionService.UpdateAsync(
            id: id,
            userId: userId,
            transactionType: transactionType,
            amount: request.Amount,
            date: request.Date,
            subject: request.Subject,
            notes: request.Notes,
            paymentMethod: paymentMethod,
            categoryId: request.CategoryId,
            transactionGroupId: request.TransactionGroupId,
            cancellationToken: cancellationToken);

        if (result.IsError)
        {
            _logger.LogWarning(&quot;Failed to update transaction {TransactionId} for user {UserId}: {Errors}&quot;,
                id, userId, string.Join(&quot;, &quot;, result.Errors.Select(e =&gt; e.Description)));
            return Problem(result.Errors);
        }

        var transaction = result.Value;
        return Ok(transaction.ToResponse());
    }

    /// &lt;summary&gt;
    /// Delete a transaction.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot;&gt;Transaction ID to delete&lt;/param&gt;
    /// &lt;param name=&quot;cancellationToken&quot;&gt;Cancellation token&lt;/param&gt;
    /// &lt;returns&gt;No content on success&lt;/returns&gt;
    /// &lt;response code=&quot;204&quot;&gt;Transaction deleted successfully&lt;/response&gt;
    /// &lt;response code=&quot;401&quot;&gt;User not authenticated&lt;/response&gt;
    /// &lt;response code=&quot;404&quot;&gt;Transaction not found&lt;/response&gt;
    [HttpDelete(&quot;{id:int}&quot;)]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
    public async Task&lt;IActionResult&gt; DeleteTransaction(int id, CancellationToken cancellationToken = default)
    {
        if (id &lt;= 0)
        {
            _logger.LogWarning(&quot;Invalid transaction ID {TransactionId} provided by user {UserId}&quot;, id, GetUserId());
            return Problem(TransactionErrors.InvalidTransactionId);
        }

        var unauthorizedResult = CheckUserContext();
        if (unauthorizedResult != null) return unauthorizedResult;

        var userId = GetRequiredUserId();

        var result = await _transactionService.DeleteAsync(id, userId, cancellationToken);

        if (result.IsError)
        {
            _logger.LogWarning(&quot;Failed to delete transaction {TransactionId} for user {UserId}: {Errors}&quot;,
                id, userId, string.Join(&quot;, &quot;, result.Errors.Select(e =&gt; e.Description)));
            return Problem(result.Errors);
        }

        return NoContent();
    }

    /// &lt;summary&gt;
    /// Parses a comma-separated string into a string array.
    /// &lt;/summary&gt;
    private static string[]? ParseCommaSeparatedArray(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;

        return value.Split(&#39;,&#39;, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
    }

    /// &lt;summary&gt;
    /// Parses a comma-separated string of integers into an int array.
    /// &lt;/summary&gt;
    private static int[]? ParseCommaSeparatedIntArray(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;

        var parts = value.Split(&#39;,&#39;, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        var result = new List&lt;int&gt;();

        foreach (var part in parts)
        {
            if (int.TryParse(part, out var intValue))
            {
                result.Add(intValue);
            }
        }

        return result.Count &gt; 0 ? result.ToArray() : null;
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,5,29,47,1],[30,5,30,6,1],[31,9,31,113,1],[32,9,32,77,1],[33,5,33,6,1],[81,5,81,6,1],[82,9,82,53,1],[83,9,83,40,1],[83,41,83,67,0],[85,9,85,42,1],[88,9,106,11,1],[109,9,109,72,1],[110,9,110,33,1],[111,9,111,10,1],[112,13,113,74,1],[113,74,113,87,1],[113,87,113,91,1],[114,13,114,48,1],[117,9,117,40,0],[119,9,119,110,0],[121,9,121,28,0],[122,9,122,10,0],[123,13,124,69,0],[124,69,124,82,0],[124,82,124,86,0],[125,13,125,43,0],[128,9,128,33,0],[129,5,129,6,1],[146,5,146,6,1],[147,9,147,21,1],[148,9,148,10,1],[149,13,149,117,1],[150,13,150,68,1],[153,9,153,53,1],[154,9,154,40,1],[154,41,154,67,0],[155,9,155,42,1],[156,9,156,84,1],[158,9,158,28,1],[159,9,159,10,1],[160,13,161,73,1],[161,73,161,86,1],[161,86,161,90,1],[162,13,162,43,1],[165,9,165,40,1],[166,9,166,45,1],[167,5,167,6,1],[187,5,187,6,1],[188,9,188,53,1],[189,9,189,40,1],[189,41,189,67,0],[191,9,191,42,1],[194,9,194,80,1],[195,9,195,33,1],[196,9,196,10,1],[197,13,198,74,1],[198,74,198,87,1],[198,87,198,91,1],[199,13,199,48,1],[202,9,202,66,1],[204,9,214,51,1],[216,9,216,28,1],[217,9,217,10,1],[218,13,219,69,1],[219,69,219,82,1],[219,82,219,86,1],[220,13,220,43,1],[223,9,223,40,1],[224,9,224,128,1],[225,5,225,6,1],[247,5,247,6,1],[248,9,248,21,1],[249,9,249,10,1],[250,13,250,117,1],[251,13,251,68,1],[254,9,254,53,1],[255,9,255,40,1],[255,41,255,67,0],[257,9,257,42,1],[260,9,260,80,1],[261,9,261,33,1],[262,9,262,10,1],[263,13,264,74,1],[264,74,264,87,1],[264,87,264,91,1],[265,13,265,48,1],[268,9,268,66,1],[270,9,281,51,1],[283,9,283,28,1],[284,9,284,10,1],[285,13,286,73,1],[286,73,286,86,1],[286,86,286,90,1],[287,13,287,43,1],[290,9,290,40,1],[291,9,291,45,1],[292,5,292,6,1],[308,5,308,6,1],[309,9,309,21,1],[310,9,310,10,1],[311,13,311,117,1],[312,13,312,68,1],[315,9,315,53,1],[316,9,316,40,1],[316,41,316,67,0],[318,9,318,42,1],[320,9,320,91,1],[322,9,322,28,1],[323,9,323,10,1],[324,13,325,73,1],[325,73,325,86,1],[325,86,325,90,1],[326,13,326,43,1],[329,9,329,28,1],[330,5,330,6,1],[336,5,336,6,1],[337,9,337,46,1],[338,13,338,25,1],[340,9,340,105,0],[341,5,341,6,1],[347,5,347,6,1],[348,9,348,46,1],[349,13,349,25,1],[351,9,351,110,0],[352,9,352,38,0],[354,9,354,16,0],[354,18,354,26,0],[354,27,354,29,0],[354,30,354,35,0],[355,9,355,10,0],[356,13,356,54,0],[357,13,357,14,0],[358,17,358,38,0],[359,13,359,14,0],[360,9,360,10,0],[362,9,362,59,0],[363,5,363,6,1]]);
    </script>
  </body>
</html>