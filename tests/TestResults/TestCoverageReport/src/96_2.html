<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/bax/Desktop/kodecta-academy/expense-tracker/src/ExpenseTrackerAPI.Application/Users/UserService.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using ErrorOr;
using ExpenseTrackerAPI.Application.Common.Interfaces;
using ExpenseTrackerAPI.Application.Users.Interfaces.Application;
using ExpenseTrackerAPI.Application.Users.Interfaces.Infrastructure;
using ExpenseTrackerAPI.Contracts.Users;
using ExpenseTrackerAPI.Domain.Entities;
using ExpenseTrackerAPI.Domain.Errors;

namespace ExpenseTrackerAPI.Application.Users;

/// &lt;summary&gt;
/// Service implementation for user business operations.
/// Handles registration, authentication, and password management using BCrypt and JWT.
/// &lt;/summary&gt;
public class UserService : IUserService
{
    private readonly IUserRepository _userRepository;
    private readonly IJwtTokenGenerator _jwtTokenGenerator;

    public UserService(
        IUserRepository userRepository,
        IJwtTokenGenerator jwtTokenGenerator)
    {
        _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository));
        _jwtTokenGenerator = jwtTokenGenerator ?? throw new ArgumentNullException(nameof(jwtTokenGenerator));
    }

    public async Task&lt;ErrorOr&lt;RegisterResponse&gt;&gt; RegisterAsync(RegisterRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var passwordHash = BCrypt.Net.BCrypt.HashPassword(request.Password, BCrypt.Net.BCrypt.GenerateSalt());

            var user = new User(
                name: request.Name,
                email: request.Email,
                passwordHash: passwordHash,
                initialBalance: request.InitialBalance ?? 0);

            var createResult = await _userRepository.CreateAsync(user, cancellationToken);
            if (createResult.IsError)
                return createResult.Errors;

            var createdUser = createResult.Value;

            return new RegisterResponse(
                Id: createdUser.Id,
                Name: createdUser.Name,
                Email: createdUser.Email,
                InitialBalance: createdUser.InitialBalance,
                CreatedAt: createdUser.CreatedAt);
        }
        catch (Exception ex)
        {
            return UserErrors.RegistrationFailed(ex.Message);
        }
    }

    public async Task&lt;ErrorOr&lt;LoginResponse&gt;&gt; LoginAsync(LoginRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var userResult = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
            if (userResult.IsError)
            {
                return UserErrors.InvalidCredentials;
            }

            var user = userResult.Value;

            if (!BCrypt.Net.BCrypt.Verify(request.Password, user.PasswordHash))
            {
                return UserErrors.InvalidCredentials;
            }

            var token = _jwtTokenGenerator.GenerateToken(user.Id, user.Email, user.Name);
            var expiresAt = DateTime.UtcNow.AddHours(_jwtTokenGenerator.TokenExpirationHours);

            return new LoginResponse(
                Id: user.Id,
                Name: user.Name,
                Email: user.Email,
                InitialBalance: user.InitialBalance,
                Token: token,
                ExpiresAt: expiresAt);
        }
        catch (Exception ex)
        {
            return UserErrors.LoginFailed(ex.Message);
        }
    }

    public async Task&lt;ErrorOr&lt;UpdateUserResponse&gt;&gt; UpdateAsync(int userId, UpdateUserRequest request, CancellationToken cancellationToken)
    {
        if (userId &lt;= 0)
            return UserErrors.InvalidUserId;

        try
        {
            var userResult = await _userRepository.GetByIdAsync(userId, cancellationToken);
            if (userResult.IsError)
                return userResult.Errors;

            var user = userResult.Value;

            if (!BCrypt.Net.BCrypt.Verify(request.CurrentPassword, user.PasswordHash))
            {
                return UserErrors.InvalidCredentials;
            }

            if (!string.Equals(user.Email, request.Email.Trim(), StringComparison.OrdinalIgnoreCase))
            {
                var existsResult = await _userRepository.ExistsByEmailAsync(request.Email, cancellationToken);
                if (existsResult.IsError)
                    return existsResult.Errors;

                if (existsResult.Value)
                    return UserErrors.DuplicateEmail;
            }

            string newPasswordHash = user.PasswordHash;
            if (!string.IsNullOrWhiteSpace(request.NewPassword))
            {
                if (!HasValidPasswordComplexity(request.NewPassword))
                    return UserErrors.WeakPassword;

                newPasswordHash = BCrypt.Net.BCrypt.HashPassword(request.NewPassword, BCrypt.Net.BCrypt.GenerateSalt());
            }

            user.UpdateProfile(request.Name, request.Email);
            user.UpdateInitialBalance(request.InitialBalance);

            if (newPasswordHash != user.PasswordHash)
            {
                user.UpdatePassword(newPasswordHash);
            }

            var updateResult = await _userRepository.UpdateAsync(user, cancellationToken);
            if (updateResult.IsError)
                return updateResult.Errors;

            var updatedUser = updateResult.Value;

            return new UpdateUserResponse(
                Id: updatedUser.Id,
                Name: updatedUser.Name,
                Email: updatedUser.Email,
                InitialBalance: updatedUser.InitialBalance,
                UpdatedAt: updatedUser.UpdatedAt);
        }
        catch (ArgumentException)
        {
            return UserErrors.InvalidEmail;
        }
        catch (Exception ex)
        {
            return UserErrors.UpdateFailed(ex.Message);
        }
    }

    public async Task&lt;ErrorOr&lt;DeleteUserResponse&gt;&gt; DeleteAsync(int userId, DeleteUserRequest request, CancellationToken cancellationToken)
    {
        if (userId &lt;= 0)
            return UserErrors.InvalidUserId;

        if (string.IsNullOrWhiteSpace(request.CurrentPassword))
            return UserErrors.PasswordRequired;

        if (!request.ConfirmDeletion)
            return UserErrors.DeletionConfirmation;

        try
        {
            var userResult = await _userRepository.GetByIdAsync(userId, cancellationToken);
            if (userResult.IsError)
                return userResult.Errors;

            var user = userResult.Value;

            if (!BCrypt.Net.BCrypt.Verify(request.CurrentPassword, user.PasswordHash))
            {
                return UserErrors.InvalidCredentials;
            }

            var deleteResult = await _userRepository.DeleteAsync(userId, cancellationToken);
            if (deleteResult.IsError)
                return deleteResult.Errors;

            return new DeleteUserResponse(
                Id: user.Id,
                Name: user.Name,
                Email: user.Email,
                Message: &quot;User account has been permanently deleted.&quot;
            );
        }
        catch (Exception ex)
        {
            return UserErrors.DeleteFailed(ex.Message);
        }
    }

    /// &lt;summary&gt;
    /// Validate password complexity requirements.
    /// &lt;/summary&gt;
    private static bool HasValidPasswordComplexity(string password)
    {
        if (string.IsNullOrWhiteSpace(password))
            return false;

        var hasUppercase = password.Any(char.IsUpper);
        var hasLowercase = password.Any(char.IsLower);
        var hasDigit = password.Any(char.IsDigit);
        var hasSpecialChar = password.Any(c =&gt; !char.IsLetterOrDigit(c));

        return hasUppercase &amp;&amp; hasLowercase &amp;&amp; hasDigit &amp;&amp; hasSpecialChar;
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[20,5,22,46,1],[23,5,23,6,1],[24,9,24,101,1],[25,9,25,110,1],[26,5,26,6,1],[29,5,29,6,1],[31,9,31,10,1],[32,13,32,115,1],[34,13,38,62,1],[40,13,40,91,1],[41,13,41,38,1],[42,17,42,44,1],[44,13,44,50,1],[46,13,51,51,1],[53,9,53,29,1],[54,9,54,10,1],[55,13,55,62,1],[57,5,57,6,1],[60,5,60,6,1],[62,9,62,10,1],[63,13,63,102,1],[64,13,64,36,1],[65,13,65,14,1],[66,17,66,54,1],[69,13,69,41,1],[71,13,71,80,1],[72,13,72,14,1],[73,17,73,54,1],[76,13,76,90,1],[77,13,77,95,1],[79,13,85,39,1],[87,9,87,29,1],[88,9,88,10,1],[89,13,89,55,1],[91,5,91,6,1],[94,5,94,6,1],[95,9,95,25,1],[96,13,96,45,1],[99,9,99,10,1],[100,13,100,92,1],[101,13,101,36,1],[102,17,102,42,1],[104,13,104,41,1],[106,13,106,87,1],[107,13,107,14,1],[108,17,108,54,1],[111,13,111,102,1],[112,13,112,14,1],[113,17,113,111,1],[114,17,114,42,1],[115,21,115,48,0],[117,17,117,40,1],[118,21,118,54,1],[119,13,119,14,1],[121,13,121,56,1],[122,13,122,65,1],[123,13,123,14,1],[124,17,124,70,1],[125,21,125,52,1],[127,17,127,121,1],[128,13,128,14,1],[130,13,130,61,1],[131,13,131,63,1],[133,13,133,54,1],[134,13,134,14,1],[135,17,135,54,1],[136,13,136,14,1],[138,13,138,91,1],[139,13,139,38,1],[140,17,140,44,0],[142,13,142,50,1],[144,13,149,51,1],[151,9,151,34,0],[152,9,152,10,0],[153,13,153,44,0],[155,9,155,29,0],[156,9,156,10,0],[157,13,157,56,0],[159,5,159,6,1],[162,5,162,6,1],[163,9,163,25,1],[164,13,164,45,1],[166,9,166,64,1],[167,13,167,48,1],[169,9,169,38,1],[170,13,170,52,1],[173,9,173,10,1],[174,13,174,92,1],[175,13,175,36,1],[176,17,176,42,0],[178,13,178,41,1],[180,13,180,87,1],[181,13,181,14,1],[182,17,182,54,1],[185,13,185,93,1],[186,13,186,38,1],[187,17,187,44,0],[189,13,194,15,1],[196,9,196,29,0],[197,9,197,10,0],[198,13,198,56,0],[200,5,200,6,1],[206,5,206,6,1],[207,9,207,49,1],[208,13,208,26,0],[210,9,210,55,1],[211,9,211,55,1],[212,9,212,51,1],[213,9,213,48,1],[213,48,213,72,1],[213,72,213,74,1],[215,9,215,75,1],[216,5,216,6,1]]);
    </script>
  </body>
</html>